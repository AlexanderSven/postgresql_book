<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Postgresql для професионалов</TITLE>
<META NAME="description" CONTENT="Postgresql для професионалов">
<META NAME="keywords" CONTENT="postgresql">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="postgresql.css">

</HEAD>

<BODY >

<P>

При написании книги(мануала, или просто шпаргалки) использовались материалы:

<UL>
<LI>PostgreSQL: настройка производительности. Алексей Борзов (Sad Spirit) borz_off@cs.msu.su, 
<BR>
http://www.phpclub.ru/detail/store/pdf/postgresql-performance.pdf
</LI>
<LI>Настройка репликации в PostgreSQL с помощью системы Slony-I, Eugene Kuzin eugene@kuzin.net, 
<BR>
http://www.kuzin.net/work/sloniki-privet.html
</LI>
<LI>Установка Londiste в подробностях, Sergey Konoplev gray.ru@gmail.com, 
<BR>
http://gray-hemp.blogspot.com/2010/04/londiste.html
</LI>
<LI>Учебное руководство по pgpool-II, Dmitry Stasyuk, 
<BR>
http://undenied.ru/2009/03/04/uchebnoe-rukovodstvo-po-pgpool-ii/
</LI>
<LI>Горизонтальное масштабирование PostgreSQL с помощью PL/Proxy, Чиркин Дима dmitry.chirkin@gmail.com, 
<BR>
http://habrahabr.ru/blogs/postgresql/45475/
</LI>
<LI>Hadoop, Иван Блинков wordpress@insight-it.ru, 
<BR>
http://www.insight-it.ru/masshtabiruemost/hadoop/
</LI>
<LI>Up and Running with HadoopDB, Padraig O'Sullivan, 
<BR>
http://posulliv.github.com/2010/05/10/hadoopdb-mysql.html
</LI>
<LI>Масштабирование PostgreSQL: готовые решения от Skype, Иван Золотухин, 
<BR>
http://postgresmen.ru/articles/view/25
</LI>
</UL>

<P>


<P>
ell
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html176"
  HREF="postgresql.html#SECTION00200000000000000000">Настройка производительности</A>
<UL>
<LI><A NAME="tex2html177"
  HREF="postgresql.html#SECTION00210000000000000000">Введение</A>
<UL>
<LI><A NAME="tex2html178"
  HREF="postgresql.html#SECTION00211000000000000000">Не используйте настройки по умолчанию</A>
<LI><A NAME="tex2html179"
  HREF="postgresql.html#SECTION00212000000000000000">Используйте актуальную версию сервера</A>
<LI><A NAME="tex2html180"
  HREF="postgresql.html#SECTION00213000000000000000">Стоит ли доверять тестам производительности</A>
</UL>
<LI><A NAME="tex2html181"
  HREF="postgresql.html#SECTION00220000000000000000">Настройка сервера</A>
<UL>
<LI><A NAME="tex2html182"
  HREF="postgresql.html#SECTION00221000000000000000">Используемая память</A>
<LI><A NAME="tex2html183"
  HREF="postgresql.html#SECTION00222000000000000000">Журнал транзакций и контрольные точки</A>
<LI><A NAME="tex2html184"
  HREF="postgresql.html#SECTION00223000000000000000">Планировщик запросов</A>
<LI><A NAME="tex2html185"
  HREF="postgresql.html#SECTION00224000000000000000">Сбор статистики</A>
</UL>
<LI><A NAME="tex2html186"
  HREF="postgresql.html#SECTION00230000000000000000">Диски и файловые системы</A>
<UL>
<LI><A NAME="tex2html187"
  HREF="postgresql.html#SECTION00231000000000000000">Перенос журнала транзакций на отдельный диск</A>
</UL>
<LI><A NAME="tex2html188"
  HREF="postgresql.html#SECTION00240000000000000000">Примеры настроек</A>
<UL>
<LI><A NAME="tex2html189"
  HREF="postgresql.html#SECTION00241000000000000000">Среднестатическая настройка для максимальной производительности</A>
<LI><A NAME="tex2html190"
  HREF="postgresql.html#SECTION00242000000000000000">Среднестатическая настройка для оконного приложения (1С), 2 ГБ памяти</A>
<LI><A NAME="tex2html191"
  HREF="postgresql.html#SECTION00243000000000000000">Среднестатическая настройка для Web приложения, 2 ГБ памяти</A>
<LI><A NAME="tex2html192"
  HREF="postgresql.html#SECTION00244000000000000000">Среднестатическая настройка для Web приложения, 8 ГБ памяти</A>
</UL>
<LI><A NAME="tex2html193"
  HREF="postgresql.html#SECTION00250000000000000000">Автоматическое создание оптимальных настроек: pgtune</A>
<LI><A NAME="tex2html194"
  HREF="postgresql.html#SECTION00260000000000000000">Оптимизация БД и приложения</A>
<UL>
<LI><A NAME="tex2html195"
  HREF="postgresql.html#SECTION00261000000000000000">Поддержание базы в порядке</A>
<LI><A NAME="tex2html196"
  HREF="postgresql.html#SECTION00262000000000000000">Использование индексов</A>
<LI><A NAME="tex2html197"
  HREF="postgresql.html#SECTION00263000000000000000">Перенос логики на сторону сервера</A>
<LI><A NAME="tex2html198"
  HREF="postgresql.html#SECTION00264000000000000000">Оптимизация конкретных запросов</A>
<LI><A NAME="tex2html199"
  HREF="postgresql.html#SECTION00265000000000000000">Оптимизация запросов с помощью pgFouine</A>
</UL>
<LI><A NAME="tex2html200"
  HREF="postgresql.html#SECTION00270000000000000000">Заключение</A>
</UL>
<BR>
<LI><A NAME="tex2html201"
  HREF="postgresql.html#SECTION00300000000000000000">Репликация</A>
<UL>
<LI><A NAME="tex2html202"
  HREF="postgresql.html#SECTION00310000000000000000">Введение</A>
<LI><A NAME="tex2html203"
  HREF="postgresql.html#SECTION00320000000000000000">Slony-I</A>
<UL>
<LI><A NAME="tex2html204"
  HREF="postgresql.html#SECTION00321000000000000000">Введение</A>
<LI><A NAME="tex2html205"
  HREF="postgresql.html#SECTION00322000000000000000">Установка</A>
<LI><A NAME="tex2html206"
  HREF="postgresql.html#SECTION00323000000000000000">Настройка</A>
<LI><A NAME="tex2html207"
  HREF="postgresql.html#SECTION00324000000000000000">Общие задачи</A>
<LI><A NAME="tex2html208"
  HREF="postgresql.html#SECTION00325000000000000000">Устранение неисправностей</A>
</UL>
<LI><A NAME="tex2html209"
  HREF="postgresql.html#SECTION00330000000000000000">Londiste</A>
<UL>
<LI><A NAME="tex2html210"
  HREF="postgresql.html#SECTION00331000000000000000">Введение</A>
<LI><A NAME="tex2html211"
  HREF="postgresql.html#SECTION00332000000000000000">Установка</A>
<LI><A NAME="tex2html212"
  HREF="postgresql.html#SECTION00333000000000000000">Настройка</A>
<LI><A NAME="tex2html213"
  HREF="postgresql.html#SECTION00334000000000000000">Общие задачи</A>
<LI><A NAME="tex2html214"
  HREF="postgresql.html#SECTION00335000000000000000">Устранение неисправностей</A>
</UL>
<LI><A NAME="tex2html215"
  HREF="postgresql.html#SECTION00340000000000000000">Bucardo</A>
<UL>
<LI><A NAME="tex2html216"
  HREF="postgresql.html#SECTION00341000000000000000">Введение</A>
<LI><A NAME="tex2html217"
  HREF="postgresql.html#SECTION00342000000000000000">Установка</A>
<LI><A NAME="tex2html218"
  HREF="postgresql.html#SECTION00343000000000000000">Настройка</A>
<LI><A NAME="tex2html219"
  HREF="postgresql.html#SECTION00344000000000000000">Общие задачи</A>
</UL>
<LI><A NAME="tex2html220"
  HREF="postgresql.html#SECTION00350000000000000000">RubyRep</A>
<UL>
<LI><A NAME="tex2html221"
  HREF="postgresql.html#SECTION00351000000000000000">Введение</A>
<LI><A NAME="tex2html222"
  HREF="postgresql.html#SECTION00352000000000000000">Установка</A>
<LI><A NAME="tex2html223"
  HREF="postgresql.html#SECTION00353000000000000000">Настройка</A>
<LI><A NAME="tex2html224"
  HREF="postgresql.html#SECTION00354000000000000000">Устранение неисправностей</A>
</UL>
<LI><A NAME="tex2html225"
  HREF="postgresql.html#SECTION00360000000000000000">Заключение</A>
</UL>
<BR>
<LI><A NAME="tex2html226"
  HREF="postgresql.html#SECTION00400000000000000000">Кластеризация БД</A>
<UL>
<LI><A NAME="tex2html227"
  HREF="postgresql.html#SECTION00410000000000000000">Введение</A>
<LI><A NAME="tex2html228"
  HREF="postgresql.html#SECTION00420000000000000000">PL/Proxy</A>
<UL>
<LI><A NAME="tex2html229"
  HREF="postgresql.html#SECTION00421000000000000000">Установка</A>
<LI><A NAME="tex2html230"
  HREF="postgresql.html#SECTION00422000000000000000">Настройка</A>
<LI><A NAME="tex2html231"
  HREF="postgresql.html#SECTION00423000000000000000">Все ли так просто?</A>
</UL>
<LI><A NAME="tex2html232"
  HREF="postgresql.html#SECTION00430000000000000000">HadoopDB</A>
<UL>
<LI><A NAME="tex2html233"
  HREF="postgresql.html#SECTION00431000000000000000">Установка и настройка</A>
<LI><A NAME="tex2html234"
  HREF="postgresql.html#SECTION00432000000000000000">Заключение</A>
</UL>
<LI><A NAME="tex2html235"
  HREF="postgresql.html#SECTION00440000000000000000">Заключение</A>
</UL>
<BR>
<LI><A NAME="tex2html236"
  HREF="postgresql.html#SECTION00500000000000000000">PgPool-II</A>
<UL>
<LI><A NAME="tex2html237"
  HREF="postgresql.html#SECTION00510000000000000000">Введение</A>
<LI><A NAME="tex2html238"
  HREF="postgresql.html#SECTION00520000000000000000">Давайте начнем!</A>
<UL>
<LI><A NAME="tex2html239"
  HREF="postgresql.html#SECTION00521000000000000000">Установка pgpool-II</A>
<LI><A NAME="tex2html240"
  HREF="postgresql.html#SECTION00522000000000000000">Файлы конфигурации</A>
<LI><A NAME="tex2html241"
  HREF="postgresql.html#SECTION00523000000000000000">Настройка команд PCP</A>
<LI><A NAME="tex2html242"
  HREF="postgresql.html#SECTION00524000000000000000">Подготовка узлов базы данных</A>
<LI><A NAME="tex2html243"
  HREF="postgresql.html#SECTION00525000000000000000">Запуск/Остановка pgpool-II</A>
</UL>
<LI><A NAME="tex2html244"
  HREF="postgresql.html#SECTION00530000000000000000">Ваша первая репликация</A>
<UL>
<LI><A NAME="tex2html245"
  HREF="postgresql.html#SECTION00531000000000000000">Настройка репликации</A>
<LI><A NAME="tex2html246"
  HREF="postgresql.html#SECTION00532000000000000000">Проверка репликации</A>
</UL>
<LI><A NAME="tex2html247"
  HREF="postgresql.html#SECTION00540000000000000000">Ваш первый параллельный запрос</A>
<UL>
<LI><A NAME="tex2html248"
  HREF="postgresql.html#SECTION00541000000000000000">Настройка параллельного запроса</A>
<LI><A NAME="tex2html249"
  HREF="postgresql.html#SECTION00542000000000000000">Настройка SystemDB</A>
<LI><A NAME="tex2html250"
  HREF="postgresql.html#SECTION00543000000000000000">Установка правил распределения данных</A>
<LI><A NAME="tex2html251"
  HREF="postgresql.html#SECTION00544000000000000000">Установка правил репликации</A>
<LI><A NAME="tex2html252"
  HREF="postgresql.html#SECTION00545000000000000000">Проверка параллельного запроса</A>
</UL>
<LI><A NAME="tex2html253"
  HREF="postgresql.html#SECTION00550000000000000000">Master-slave режим</A>
<LI><A NAME="tex2html254"
  HREF="postgresql.html#SECTION00560000000000000000">Онлайн востановление</A>
<LI><A NAME="tex2html255"
  HREF="postgresql.html#SECTION00570000000000000000">Заключение</A>
</UL>
<BR>
<LI><A NAME="tex2html256"
  HREF="postgresql.html#SECTION00600000000000000000">Мультиплексоры соединений</A>
<UL>
<LI><A NAME="tex2html257"
  HREF="postgresql.html#SECTION00610000000000000000">Введение</A>
<LI><A NAME="tex2html258"
  HREF="postgresql.html#SECTION00620000000000000000">PgBouncer</A>
<LI><A NAME="tex2html259"
  HREF="postgresql.html#SECTION00630000000000000000">PgPool-II vs PgBouncer</A>
</UL></UL>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION00200000000000000000">
Настройка производительности</A>
</H1>

<H1><A NAME="SECTION00210000000000000000">
Введение</A>
</H1>
Скорость работы, вообще говоря, не является основной причиной использования реляционных СУБД. 
Более того, первые реляционные базы работали медленнее своих предшественников. 
Выбор этой технологии был вызван скорее

<UL>
<LI>возможностью возложить поддержку целостности данных на СУБД;
</LI>
<LI>независимостью логической структуры данных от физической.
</LI>
</UL>

<P>
Эти особенности позволяют сильно упростить написание приложений, но требуют для 
своей реализации дополнительных ресурсов.

<P>
Таким образом, прежде, чем искать ответ на вопрос &#171;как заставить РСУБД работать быстрее в моей задаче?&#187; 
следует ответить на вопрос &#171;нет ли более подходящего средства для решения моей задачи, чем РСУБД?&#187; 
Иногда использование другого средства потребует меньше усилий, чем настройка производительности.

<P>
Данная глава посвящена возможностям повышения производительности PostgreSQL. 
Глава не претендует на исчерпывающее изложение вопроса, наиболее полным и точным руководством по 
использованию PostgreSQL является, конечно, официальная документация и официальный FAQ. 
Также существует англоязычный список рассылки postgresql-performance, посвящённый именно этим вопросам.
Глава состоит из двух разделов, первый из которых ориентирован скорее на администратора, 
второй&nbsp;-- на разработчика приложений. Рекомендуется прочесть оба раздела: отнесение многих вопросов к 
какому-то одному из них весьма условно.

<P>

<H2><A NAME="SECTION00211000000000000000">
Не используйте настройки по умолчанию</A>
</H2>
По умолчанию PostgreSQL сконфигурирован таким образом, чтобы он мог быть запущен практически 
на любом компьютере и не слишком мешал при этом работе других приложений. Это особенно касается используемой памяти. 
Настройки по умолчанию подходят только для следующего использования:
с ними вы сможете проверить, работает ли установка PostgreSQL, создать тестовую базу 
уровня записной книжки и потренироваться писать к ней запросы.
Если вы собираетесь разрабатывать (а тем более запускать в работу) реальные 
приложения, то настройки придётся радикально изменить.
В дистрибутиве PostgreSQL, к сожалению, не поставляется файлов с &#171;рекомендуемыми&#187; настройками. 
Вообще говоря, такие файлы создать весьма сложно, т.к. оптимальные настройки конкретной 
установки PostgreSQL будут определяться:

<UL>
<LI>конфигурацией компьютера;
</LI>
<LI>объёмом и типом данных, хранящихся в базе;
</LI>
<LI>отношением числа запросов на чтение и на запись;
</LI>
<LI>тем, запущены ли другие требовательные к ресурсам процессы (например, вебсервер).
</LI>
</UL>

<P>

<H2><A NAME="SECTION00212000000000000000">
Используйте актуальную версию сервера</A>
</H2>
Если у вас стоит устаревшая версия PostgreSQL, то наибольшего ускорения работы вы сможете 
добиться, обновив её до текущей. Укажем лишь наиболее значительные из связанных с производительностью изменений.

<UL>
<LI>В версии 7.1 появился журнал транзакций, до того данные в таблицу сбрасывались каждый раз при успешном завершении транзакции.
</LI>
<LI>В версии 7.2 появились:

<UL>
<LI>новая версия команды VACUUM, не требующая блокировки;
</LI>
<LI>команда ANALYZE, строящая гистограмму распределения данных в столбцах, что позволяет выбирать более 
быстрые планы выполнения запросов;
</LI>
<LI>подсистема сбора статистики.
</LI>
</UL>
</LI>
<LI>В версии 7.4 была ускорена работа многих сложных запросов (включая печально известные подзапросы IN/NOT IN).
</LI>
<LI>В версии 8.0 было внедрено метки востановления, улучшение управления буфером, CHECKPOINT и VACUUM улучшены.
</LI>
<LI>В версии 8.1 было улучшено одновременный доступ к разделяемой памяти, автоматически использование индексов для MIN() и MAX(),
pg_autovacuum внедрен в сервер (автоматизирован), повышение производительности для секционированных таблиц.
</LI>
<LI>В версии 8.2 было улучшено скорость множества SQL запросов, усовершенствован сам язык запросов. 
</LI>
<LI>В версии 8.3 внедрен полнотекстовый поиск, поддержка SQL/XML стандарта, параметры конфигурации сервера могут быть 
установлены на основе отдельных функций.
</LI>
<LI>В версии 8.4 было внедрено общие табличные выражения, рекурсивные запросы, параллельное восстановление, улучшенна 
производительность для EXISTS/NOT EXISTS запросов.
</LI>
<LI>В версии 9.0 &#171;репликация из коробки&#187;, VACUUM/VACUUM FULL стали быстрее, расширены хранимые процедуры.
</LI>
</UL>
Следует также отметить, что большая часть изложенного в статье материала относится к версии сервера не ниже 8.4.

<P>

<H2><A NAME="SECTION00213000000000000000">
Стоит ли доверять тестам производительности</A>
</H2>
Перед тем, как заниматься настройкой сервера, вполне естественно ознакомиться с опубликованными данными по 
производительности, в том числе в сравнении с другими СУБД. К сожалению, многие тесты служат не столько для 
облегчения вашего выбора, сколько для продвижения конкретных продуктов в качестве &#171;самых быстрых&#187;.
При изучении опубликованных тестов в первую очередь обратите внимание, соответствует ли величина и тип 
нагрузки, объём данных и сложность запросов в тесте тому, что вы собираетесь делать с базой? Пусть, например, 
обычное использование вашего приложения подразумевает несколько одновременно работающих 
запросов на обновление к таблице в миллионы записей. В этом случае СУБД, которая в несколько раз 
быстрее всех остальных ищет запись в таблице в тысячу записей, может оказаться не лучшим выбором.
Ну и наконец, вещи, которые должны сразу насторожить:

<UL>
<LI>Тестирование устаревшей версии СУБД.
</LI>
<LI>Использование настроек по умолчанию (или отсутствие информации о настройках).
</LI>
<LI>Тестирование в однопользовательском режиме (если, конечно, вы не предполагаете использовать СУБД именно так).
</LI>
<LI>Использование расширенных возможностей одной СУБД при игнорировании расширенных возможностей другой.
</LI>
<LI>Использование заведомо медленно работающих запросов (см. пункт 3.4).
</LI>
</UL>

<H1><A NAME="SECTION00220000000000000000">
Настройка сервера</A>
</H1>
В этом разделе описаны рекомендуемые значения параметров, влияющих на производительность СУБД. Эти параметры 
обычно устанавливаются в конфигурационном файле postgresql.conf и влияют на все базы в текущей установке.

<P>

<H2><A NAME="SECTION00221000000000000000">
Используемая память</A>
</H2>

<H3><A NAME="SECTION00221100000000000000">
Общий буфер сервера: shared_buffers</A>
</H3>
PostgreSQL не читает данные напрямую с диска и не пишет их сразу на диск. Данные загружаются в общий буфер сервера, 
находящийся в разделяемой памяти, серверные процессы читают и пишут блоки в этом буфере, а затем уже 
изменения сбрасываются на диск. 

<P>
Если процессу нужен доступ к таблице, то он сначала ищет нужные блоки в 
общем буфере. Если блоки присутствуют, то он может продолжать работу, если нет&nbsp;-- делается системный вызов для 
их загрузки. Загружаться блоки могут как из файлового кэша ОС, так и с диска, и эта операция может оказаться весьма &#171;дорогой&#187;.

<P>
Если объём буфера недостаточен для хранения часто используемых рабочих данных, то они будут постоянно 
писаться и читаться из кэша ОС или с диска, что крайне отрицательно скажется на производительности.

<P>
В то же время не следует устанавливать это значение слишком большим:
это НЕ вся память, которая нужна для работы PostgreSQL, это только размер разделяемой между процессами PostgreSQL памяти, 
которая нужна для выполнения активных операций. Она должна занимать меньшую часть оперативной памяти вашего компьютера, так как 
PostgreSQL полагается на то, что операционная система кэширует файлы, и не 
старается дублировать эту работу. Кроме того, чем больше памяти будет отдано под буфер, тем 
меньше останется операционной системе и другим приложениям, что может привести к своппингу.

<P>
К сожалению, чтобы знать точное число shared_buffers, нужно 
учесть количество оперативной памяти компьютера, размер базы данных, число соединений и сложность запросов, так что лучше 
воспользуемся несколькими простыми правилами настройки.

<P>
На выделенных серверах полезным объемом будет значение от 8 МБ до 2 ГБ. 
Объем может быть выше, если у вас большие активные порции базы данных, сложные запросы, большое число 
одновременных соединений, длительные транзакции, вам доступен большой объем оперативной памяти или большее количество 
процессоров. И, конечно же, не забываем об остальных приложениях. Выделив слишком много памяти для базы данных, 
мы можем получить ухудшение производительности. 
В качестве начальных значений можете попробовать следующие:

<UL>
<LI>Начните с 4 МБ (512) для рабочей станции
</LI>
<LI>Средний объём данных и 256-512 МБ доступной памяти: 16-32 МБ (2048-4096)
</LI>
<LI>Большой объём данных и 1-4 ГБ доступной памяти: 64-256 МБ (8192-32768)
</LI>
</UL>

<P>
Для тонкой настройки параметра установите для него большое значение и потестируйте базу при обычной нагрузке. 
Проверяйте использование разделяемой памяти при помощи ipcs или других утилит. Рекомендуемое значение параметра 
будет примерно в 1,2&nbsp;-2 раза больше, чем максимум использованной памяти. Обратите внимание, что память под буфер 
выделятся при запуске сервера, и её объём при работе не изменяется. Учтите также, что настройки ядра операционной 
системы могут не дать вам выделить большой объём памяти. В руководстве администратора PostgreSQL описано, как 
можно изменить эти настройки: http://developer.postgresql.org/docs/postgres/kernel-resources.html

<P>
Вот несколько примеров, полученных на личном опыте и при тестировании:

<UL>
<LI>Laptop, Celeron processor, 384 МБ RAM, база данных 25 МБ: 12 МБ
</LI>
<LI>Athlon server, 1 ГБ RAM, база данных поддержки принятия решений 10 ГБ: 200 МБ
</LI>
<LI>Quad PIII server, 4 ГБ RAM, 40 ГБ, 150 соединений, &#171;тяжелые&#187; транзакции: 1 ГБ
</LI>
<LI>Quad Xeon server, 8 ГБ RAM, 200 ГБ, 300 соединений, &#171;тяжелые&#187; транзакции: 2 ГБ
</LI>
</UL>

<P>

<H3><A NAME="SECTION00221200000000000000">
Память для сортировки результата запроса: work_mem</A>
</H3>
Ранее известное как sort_mem, было переименовано, так как сейчас определяет максимальное количество оперативной памяти, 
которое может выделить одна операция сортировки, агрегации и др. Это не разделяемая память, work_mem выделяется отдельно 
на каждую операцию (от одного до нескольких раз за один запрос). Разумное значение параметра определяется следующим образом: 
количество доступной оперативной памяти (после того, как из общего объема вычли память, требуемую для других приложений, и 
shared_buffers) делится на максимальное число одновременных запросов умноженное на среднее число операций в запросе, которые 
требуют памяти.

<P>
Если объём памяти недостаточен для сортироки некоторого результата, то серверный процесс будет использовать 
временные файлы. Если же объём памяти слишком велик, то это может привести к своппингу.

<P>
Объём памяти задаётся параметром work_mem в файле postgresql.conf. Единица измерения параметра&nbsp;-- 1 кБ. 
Значение по умолчанию&nbsp;-- 1024. В качестве начального значения для параметра можете взять 2-4% доступной памяти.
Для веб-приложений обычно устанавливают низкие значения work_mem, так как запросов обычно много, но они простые, обычно хватает 
от 512 до 2048 КБ. С другой стороны, приложения для поддержки принятия решений с сотнями строк в каждом запросе и десятками 
миллионов столбцов  в таблицах фактов часто требуют work_mem порядка 500 МБ. Для баз данных, которые используются и так, и так, 
этот параметр можно устанавливать для каждого запроса индивидуально, используя настройки сессии. Например, 
при памяти 1-4 ГБ рекомендуется устанавливать 32-128 MB. 

<P>

<H3><A NAME="SECTION00221300000000000000">
Память для работы команды VACUUM: maintenance_work_mem</A>
</H3>
Предыдущее название в PostgreSQL 7.x vacuum_mem. Этот параметр задаёт объём памяти, используемый командами 
VACUUM, ANALYZE, CREATE INDEX, и добавления внешних ключей. 
Чтобы операции выполнялись максимально быстро, нужно устанавливать этот параметр тем выше, чем больше размер таблиц в 
вашей базе данных. Неплохо бы устанавливать его значение от 50 до 75% размера вашей самой большой таблицы или индекса или, 
если точно определить невозможно, от 32 до 256 МБ. Следует устанавливать большее значение, чем для work_mem. 
Слишком большие значения приведут к использованию свопа. Например, при памяти 1-4 ГБ рекомендуется устанавливать 128-512 MB.

<P>

<H3><A NAME="SECTION00221400000000000000">
Free Space Map: как избавиться от VACUUM FULL</A>
</H3>
Особенностями версионных движков БД (к которым относится и используемый в PostgreSQL) является следующее:

<UL>
<LI>Транзакции, изменяющие данные в таблице, не блокируют транзакции, читающие из неё данные, и наоборот (это хорошо);
</LI>
<LI>При изменении данных в таблице (командами UPDATE или DELETE) накапливается мусор<A NAME="tex2html1"
  HREF="#foot270"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> (а это плохо).
</LI>
</UL>
В каждой СУБД сборка мусора реализована особым образом, в PostgreSQL для этой цели применяется команда VACUUM (описана в пункте 3.1.1).

<P>
До версии 7.2 команда VACUUM полностью блокировала таблицу. Начиная с версии 7.2, команда VACUUM накладывает более слабую 
блокировку, позволяющую параллельно выполнять команды SELECT, INSERT, UPDATE и DELETE над обрабатываемой таблицей. 
Старый вариант команды называется теперь VACUUM FULL.

<P>
Новый вариант команды не пытается удалить все старые версии записей и, соответственно, уменьшить размер файла, содержащего таблицу, 
а лишь помечает занимаемое ими место как свободное. Для информации о свободном месте есть следующие настройки:

<UL>
<LI><SPAN  CLASS="textbf">max_fsm_relations</SPAN>

<P>
Максимальное количество таблиц, для которых будет отслеживаться свободное место в общей карте свободного пространства. 
Эти данные собираются VACUUM. Параметр max_fsm_relations должен быть не меньше общего количества таблиц во всех 
базах данной установки (лучше с запасом). 

<P>
</LI>
<LI><SPAN  CLASS="textbf">max_fsm_pages</SPAN>

<P>
Данный параметр определяет размер реестра, в котором хранится информация о частично освобождённых страницах данных, 
готовых к заполнению новыми данными. Значение этого параметра нужно установить чуть больше, чем полное число страниц, 
которые могут быть затронуты 
операциями обновления или удаления между выполнением VACUUM. Чтобы определить это число, можно запустить VACUUM VERBOSE ANALYZE 
и выяснить общее число страниц, используемых базой данных. max_fsm_pages обычно требует немного памяти, так что на этом 
параметре лучше не экономить. 
</LI>
</UL>

<P>
Если эти параметры установленны верно и информация обо всех изменениях помещается в FSM, 
то команды VACUUM будет достаточно для сборки мусора, если нет&nbsp;- понадобится
VACUUM FULL, во время работы которой нормальное использование БД сильно затруднено.

<P>
Начиная с 8.4 версии fsm параметры были убраны, поскольку Free Space Map сохраняется на жесткий диск, а не в память.

<P>

<H3><A NAME="SECTION00221500000000000000">
Прочие настройки</A>
</H3>

<UL>
<LI><SPAN  CLASS="textbf">temp_buffers</SPAN>

<P>
Буфер под временные объекты, в основном для временных таблиц.
Можно установить порядка 16 МБ.

<P>
</LI>
<LI><SPAN  CLASS="textbf">max_prepared_transactions</SPAN>

<P>
Количество одновременно подготавливаемых транзакций (PREPARE TRANSACTION).
Можно оставить по дефолту&nbsp;-- 5.

<P>
</LI>
<LI><SPAN  CLASS="textbf">vacuum_cost_delay</SPAN> 

<P>
Если у вас большие таблицы, и производится много одновременных операций записи, 
вам может пригодиться функция, которая уменьшает затраты на I/O для VACUUM, растягиваяя его по времени. 
Чтобы включить эту функциональность, нужно поднять 
значение vacuum_cost_delay выше 0. Используйте разумную задержку от 50 до 200 мс. Для более тонкой настройки повышайте 
vacuum_cost_page_hit и понижайте vacuum_cost_page_limit. Это ослабит влияние VACUUM, увеличив время его выполнения. 
В тестах с параллельными транзакциями Ян Вик (Jan Wieck) получил, что при значениях delay&nbsp;-- 200, page_hit&nbsp;-- 6 и предел&nbsp;-- 
100 вляние VACUUM уменьшилось более чем на 80%, но его длительность увеличилась втрое. 

<P>
</LI>
<LI><SPAN  CLASS="textbf">max_stack_depth</SPAN>

<P>
Специальный стек для сервера, в идеале он должен совпадать с размером стека, выставленном в ядре ОС. 
Установка большего значения, чем в ядре, может привести к ошибкам.
Рекомендуется устанавливать 2-4 MB.

<P>
</LI>
<LI><SPAN  CLASS="textbf">max_files_per_process</SPAN>

<P>
Максимальное количество файлов, открываемых процессом и его подпроцессами в один момент времени.
Уменьшите данный параметр, если в процессе работы наблюдается сообщение &#171;Too many open files&#187;.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00222000000000000000">
Журнал транзакций и контрольные точки</A>
</H2>
Журнал транзакций PostgreSQL работает следующим образом: все изменения в файлах данных (в которых находятся таблицы и 
индексы) производятся только после того, как они были занесены в журнал транзакций, при этом записи в журнале должны 
быть гарантированно записаны на диск.

<P>
В этом случае нет необходимости сбрасывать на диск изменения данных при каждом успешном завершении транзакции: 
в случае сбоя БД может быть восстановлена по записям в журнале. Таким образом, данные из буферов сбрасываются на диск 
при проходе контрольной точки: либо при заполнении нескольких (параметр checkpoint_segments, по умолчанию 3) сегментов
журнала транзакций, либо через определённый интервал времени (параметр checkpoint_timeout, измеряется в секундах, по умолчанию 300).

<P>
Изменение этих параметров прямо не повлияет на скорость чтения, но может принести большую пользу, если данные в базе активно изменяются.

<P>

<H3><A NAME="SECTION00222100000000000000">
Уменьшение количества контрольных точек: checkpoint_segments</A>
</H3>
Если в базу заносятся большие объёмы данных, то контрольные точки могут происходить слишком часто<A NAME="tex2html2"
  HREF="#foot286"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>. 
При этом производительность упадёт из-за постоянного сбрасывания на диск данных из буфера.

<P>
Для увеличения интервала между контрольными точками нужно увеличить количество сегментов журнала транзакций (checkpoint_segments). 
Данный параметр определяет количество сегментов (каждый по 16 МБ) лога транзакций между контрольными точками. 
Этот параметр не имеет особого значения для базы данных, предназначенной преимущественно для чтения, но для баз данных со 
множеством транзакций увеличение этого параметра может оказаться жизненно необходимым. В зависимости от объема данных 
установите этот параметр в диапазоне от 12 до 256 сегментов и, если в логе появляются предупреждения (warning) о том, что 
контрольные точки происходят слишком часто, постепенно увеличивайте его. Место, требуемое на диске, вычисляется по формуле 
(checkpoint_segments * 2 + 1) * 16 МБ, так что убедитесь, что у вас достаточно свободного места. Например, если вы выставите 
значение 32, вам потребуется больше 1 ГБ дискового пространства.

<P>
Следует также отметить, что чем больше интервал между контрольными точками, тем дольше будут восстанавливаться данные по 
журналу транзакций после сбоя.

<P>

<H3><A NAME="SECTION00222200000000000000">
fsync и стоит ли его трогать</A>
</H3>
Наиболее радикальное из возможных решений&nbsp;-- выставить значение &#171;off&#187; параметру fsync. При этом записи в журнале транзакций не 
будут принудительно сбрасываться на диск, что даст большой прирост скорости записи. Учтите: вы жертвуете надёжностью, в случае 
сбоя целостность базы будет нарушена, и её придётся восстанавливать из резервной копии!

<P>
Использовать этот параметр рекомендуется лишь в том случае, если вы всецело доверяете своему &#171;железу&#187; и своему источнику 
бесперебойного питания. Ну или если данные в базе не представляют для вас особой ценности.

<P>

<H3><A NAME="SECTION00222300000000000000">
Прочие настройки</A>
</H3>

<UL>
<LI><SPAN  CLASS="textbf">commit_delay</SPAN> (в микросекундах, 0 по умолчанию) и <SPAN  CLASS="textbf">commit_siblings</SPAN> (5 по умолчанию) 

<P>
определяют задержку между попаданием записи в буфер журнала транзакций и сбросом её на диск. 
Если при успешном завершении транзакции активно не менее commit_siblings транзакций, то запись будет задержана на время 
commit_delay. Если за это время завершится другая транзакция, то их изменения будут сброшены на диск вместе, при помощи 
одного системного вызова. Эти параметры позволят ускорить работу, если параллельно выполняется много &#171;мелких&#187; транзакций.

<P>
</LI>
<LI><SPAN  CLASS="textbf">wal_sync_method</SPAN>

<P>
Метод, который используется для принудительной записи данных на диск.
Если fsync=off, то этот параметр не используется.
Возможные значения:

<UL>
<LI>open_datasync&nbsp;-- запись данных методом open() с параметром O_DSYNC
</LI>
<LI>fdatasync&nbsp;-- вызов метода fdatasync() после каждого commit
</LI>
<LI>fsync_writethrough&nbsp;-- вызывать fsync() после каждого commit игнорирую паралельные процессы
</LI>
<LI>fsync&nbsp;-- вызов fsync() после каждого commit
</LI>
<LI>open_sync&nbsp;-- запись данных методом open() с параметром O_SYNC
</LI>
</UL>

<P>
Не все методы доступны на определенных платформах. По умолчанию устанавливается первый, который доступен в системе.

<P>
</LI>
<LI><SPAN  CLASS="textbf">full_page_writes</SPAN>

<P>
Установите данный параметр в off, если fsync=off. Иначе, когда этот параметр on, PostgreSQL записывает содержимое 
каждой страницы в журнал транзакций во время первой модификации таблицы после контрольной точки. Это необходимо потому 
что страницы могут записаться лишь частично если в ходе процесса ОС "упала". Это приволит к тому, что на диске оказаываются 
новые данные смешанные со старыми. Строкового уровня записи в журнал транзакций может быть не достаточно, что бы полность 
восстановить данные после "падения". full_page_writes гарантирует корректное восстановление, ценой увелечения записываемых 
данных в журнал транзакций.(Потому что журнал транзакций все время начинается с контрольной точки. Единственный способ 
снижения объема записи заключается в увеличении checkpoint_interval).

<P>
</LI>
<LI><SPAN  CLASS="textbf">wal_buffers</SPAN>

<P>
Количество памяти используемое в SHARED MEMORY для ведения транзакционных логов<A NAME="tex2html3"
  HREF="#foot297"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
Стоит увеличить буфер до 256-512 кБ, что позволит лучше работать с большими транзакциями.
Например, при доступной памяти 1-4 ГБ рекомендуется устанавливать 256-1024 КБ.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION00223000000000000000">
Планировщик запросов</A>
</H2>
Следующие настройки помогают планировщику запросов правильно оценивать стоимости различных 
операций и выбирать оптимальный план выполнения запроса. Существуют 2 глобальные настройки планировщика, 
на которые стоит обратить внимание:

<UL>
<LI><SPAN  CLASS="textbf">effective_cache_size</SPAN>

<P>
Этот параметр сообщает PostgreSQL примерный объём файлового кэша операционной системы, оптимизатор использует эту оценку для 
построения плана запроса<A NAME="tex2html4"
  HREF="#foot302"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.

<P>
Пусть в вашем компьютере 1,5 ГБ памяти, параметр shared_buffers установлен в 32 МБ, а параметр effective_cache_size в 800 МБ. 
Если запросу нужно 700 МБ данных, то PostgreSQL оценит, что все нужные данные уже есть в памяти и выберет более агрессивный план с 
использованием индексов и merge joins. Но если effective_cache_size будет всего 200 МБ, то оптимизатор вполне может выбрать более 
эффективный для дисковой системы план, включающий полный просмотр таблицы.

<P>
На выделенном сервере имеет смысл выставлять effective_cache_size в 2/3 от всей оперативной памяти; на сервере с 
другими приложениями сначала нужно вычесть из всего объема RAM размер дискового кэша ОС и память, 
занятую остальными процессами.

<P>
</LI>
<LI><SPAN  CLASS="textbf">random_page_cost</SPAN> 

<P>
Переменная, указывающая на условную стоимость индексного доступа к страницам данных. На серверах с быстрыми дисковыми 
массивами имеет смысл уменьшать изначальную настройку до 3.0, 2.5 или даже до 2.0. Если же активная часть вашей базы данных 
много больше размеров оперативной памяти, попробуйте поднять значение параметра. Можно подойти к выбору оптимального значения 
и со стороны производительности запросов. Если планировщик запросов чаще, чем необходимо, предпочитает последовательные просмотры 
(sequential scans) просмотрам с использованием индекса (index scans), понижайте значение. И наоборот, если планировщик выбирает 
просмотр по медленному индексу, когда не должен этого делать, настройку имеет смысл увеличить. После изменения тщательно тестируйте 
результаты на максимально широком наборе запросов. Никогда не опускайте значение random_page_cost ниже 2.0; если вам кажется, 
что random_page_cost нужно еще понижать, разумнее в этом случае менять настройки статистики планировщика. 
</LI>
</UL>

<P>

<H2><A NAME="SECTION00224000000000000000">
Сбор статистики</A>
</H2>
У PostgreSQL также есть специальная подсистема&nbsp;-- сборщик статистики,&nbsp;-- которая в реальном времени собирает данные об 
активности сервера. Эта подсистема контролируется следующими параметрами, принимающими значения true/false:

<UL>
<LI><SPAN  CLASS="textbf">default_statistics_target</SPAN> задаёт объём по умолчанию статистики, собираемой командой ANALYZE (см. пункт 3.1.2). 
Увеличение параметра заставит эту команду работать дольше, но может позволить оптимизатору строить более быстрые планы, 
используя полученные дополнительные данные. Объём статистики для конкретного поля может быть задан командой 
ALTER TABLE ...SET STATISTICS.
</LI>
<LI><SPAN  CLASS="textbf">stats_start_collector</SPAN> включать ли сбор статистики. По умолчанию включён, отключайте, только если статистика вас 
совершенно не интересует.
</LI>
<LI><SPAN  CLASS="textbf">stats_reset_on_server_start</SPAN> обнулять ли статистику при перезапуске сервера. По умолчанию&nbsp;-- обнулять.
</LI>
<LI><SPAN  CLASS="textbf">stats_command_string</SPAN> передавать ли сборщику статистики информацию о текущей выполняемой команде и времени 
начала её выполнения. По умолчанию эта возможность отключена. Следует отметить, что эта информация будет доступна только 
привилегированным пользователям и пользователям, от лица которых запущены команды, так что проблем с безопасностью быть не должно.
</LI>
<LI><SPAN  CLASS="textbf">stats_row_level</SPAN>, <SPAN  CLASS="textbf">stats_block_level</SPAN> собирать ли информацию об активности на уровне записей и 
блоков соответственно. По умолчанию сбор отключён.
</LI>
</UL>

<P>
Данные, полученные сборщиком статистики, доступны через специальные системные представления. При установках по умолчанию собирается 
очень мало информации, рекомендуется включить все возможности: дополнительная нагрузка будет невелика, в то время как полученные 
данные позволят оптимизировать использование индексов.

<H1><A NAME="SECTION00230000000000000000">
Диски и файловые системы</A>
</H1>
Очевидно, что от качественной дисковой подсистемы в сервере БД зависит немалая часть производительности. Вопросы выбора и 
тонкой настройки &#171;железа&#187;, впрочем, не являются темой данной статьи, ограничимся уровнем файловой системы.

<P>
Единого мнения насчёт наиболее подходящей для PostgreSQL файловой системы нет, поэтому рекомендуется использовать ту, которая лучше 
всего поддерживается вашей операционной системой. При этом учтите, что современные журналирующие файловые системы не намного 
медленнее нежурналирующих, а выигрыш&nbsp;-- быстрое восстановление после сбоев&nbsp;-- от их использования велик.

<P>
Вы легко можете получить выигрыш в производительности без побочных эффектов, если примонтируете файловую систему, 
содержащую базу данных, с параметром noatime<A NAME="tex2html5"
  HREF="#foot435"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.

<P>

<H2><A NAME="SECTION00231000000000000000">
Перенос журнала транзакций на отдельный диск</A>
</H2>
При доступе к диску изрядное время занимает не только собственно чтение данных, но и перемещение магнитной головки.

<P>
Если в вашем сервере есть несколько физических дисков<A NAME="tex2html6"
  HREF="#foot437"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>, то вы можете разнести файлы базы данных и журнал транзакций по разным 
дискам. Данные в сегменты журнала пишутся последовательно, более того, записи в журнале транзакций сразу сбрасываются на диск, 
поэтому в случае нахождения его на отдельном диске магнитная головка не будет лишний раз двигаться, что позволит ускорить запись.

<P>
Порядок действий:

<UL>
<LI>Остановите сервер (!).
</LI>
<LI>Перенесите каталоги pg_clog и pg_xlog, находящийся в каталоге с базами данных, на другой диск. 
</LI>
<LI>Создайте на старом месте символическую ссылку.
</LI>
<LI>Запустите сервер.
</LI>
</UL>

<P>
Примерно таким же образом можно перенести и часть файлов, содержащих таблицы и индексы, на другой диск, но здесь 
потребуется больше кропотливой ручной работы, а при внесении изменений в схему базы процедуру, возможно, придётся повторить.

<H1><A NAME="SECTION00240000000000000000">
Примеры настроек</A>
</H1>

<P>

<H2><A NAME="SECTION00241000000000000000">
Среднестатическая настройка для максимальной производительности</A>
</H2>

<P>
Возможно для конкретного случаю лучше подойдут другие настройки. Внимательно изучите данное руководство и настройте 
PostgreSQL операясь на эту информацию.

<P>
RAM&nbsp;-- размер памяти;

<UL>
<LI>shared_buffers = 1/8 RAM или больше (но не более 1/4);
</LI>
<LI>work_mem в 1/20 RAM;
</LI>
<LI>maintenance_work_mem в 1/4 RAM;
</LI>
<LI>max_fsm_relations в планируемое кол-во таблиц в базах * 1.5;
</LI>
<LI>max_fsm_pages в max_fsm_relations * 2000;
</LI>
<LI>fsync = true;
</LI>
<LI>wal_sync_method = fdatasync;
</LI>
<LI>commit_delay = от 10 до 100 ;
</LI>
<LI>commit_siblings = от 5 до 10;
</LI>
<LI>effective_cache_size = 0.9 от значения cached, которое показывает free;
</LI>
<LI>random_page_cost = 2 для быстрых cpu, 4 для медленных;
</LI>
<LI>cpu_tuple_cost = 0.001 для быстрых cpu, 0.01 для медленных;
</LI>
<LI>cpu_index_tuple_cost = 0.0005 для быстрых cpu, 0.005 для медленных;
</LI>
<LI>autovacuum = on;
</LI>
<LI>autovacuum_vacuum_threshold = 1800;
</LI>
<LI>autovacuum_analyze_threshold = 900;
</LI>
</UL>

<P>

<H2><A NAME="SECTION00242000000000000000">
Среднестатическая настройка для оконного приложения (1С), 2 ГБ памяти</A>
</H2>

<P>

<UL>
<LI>maintenance_work_mem = 128MB
</LI>
<LI>effective_cache_size = 512MB
</LI>
<LI>work_mem = 640kB
</LI>
<LI>wal_buffers = 1536kB
</LI>
<LI>shared_buffers = 128MB
</LI>
<LI>max_connections = 500
</LI>
</UL>

<P>

<H2><A NAME="SECTION00243000000000000000">
Среднестатическая настройка для Web приложения, 2 ГБ памяти</A>
</H2>

<P>

<UL>
<LI>maintenance_work_mem = 128MB;
</LI>
<LI>checkpoint_completion_target = 0.7
</LI>
<LI>effective_cache_size = 1536MB
</LI>
<LI>work_mem = 4MB
</LI>
<LI>wal_buffers = 4MB
</LI>
<LI>checkpoint_segments = 8
</LI>
<LI>shared_buffers = 512MB
</LI>
<LI>max_connections = 500
</LI>
</UL>

<P>

<H2><A NAME="SECTION00244000000000000000">
Среднестатическая настройка для Web приложения, 8 ГБ памяти</A>
</H2>

<P>

<UL>
<LI>maintenance_work_mem = 512MB
</LI>
<LI>checkpoint_completion_target = 0.7
</LI>
<LI>effective_cache_size = 6GB
</LI>
<LI>work_mem = 16MB
</LI>
<LI>wal_buffers = 4MB
</LI>
<LI>checkpoint_segments = 8
</LI>
<LI>shared_buffers = 2GB
</LI>
<LI>max_connections = 500
</LI>
</UL>

<P>

<H1><A NAME="SECTION00250000000000000000">
Автоматическое создание оптимальных настроек: pgtune</A>
</H1>

<P>
Для оптимизации настроек для PostgreSQL Gregory Smith создал утилиту pgtune<A NAME="tex2html7"
  HREF="#foot470"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> 
в расчете на обеспечение максимальной производительности для заданной аппаратной конфигурации.
Утилита проста в использовании и в многих Linux системах может идти в составе пакетов. 
Если же нет, можно просто скачать архив и распаковать.
Для начала:
<PRE>
pgtune -i $PGDATA/postgresql.conf \
-o $PGDATA/postgresql.conf.pgtune
</PRE>
опцией 
<PRE>-i, --input-config
</PRE> 
указываем текущий файл postgresql.conf, 
а 
<PRE>-o, --output-config
</PRE>
указываем имя файла для нового postgresql.conf.

<P>
Есть также дополнительные опции для настройки конфига. 

<UL>
<LI><PRE>-M, --memory
</PRE>
Используйте этот параметр, чтобы определить общий объем системной памяти. 
Если не указано, pgtune будет пытаться использовать текущий объем системной памяти.

<P>
</LI>
<LI><PRE>-T, --type
</PRE>
Указывает тип базы данных. Опции: DW,  OLTP,  Web, Mixed, Desktop.

<P>
</LI>
<LI><PRE>-c, --connections
</PRE>
Указывает максимальное количество соединений. Если он не указан, это будет братся взависимости от типа базы данных.

<P>
</LI>
</UL>

<P>
Хочется сразу добавить, что pgtune не панацея для оптимизации настройки PostgreSQL. Многие настройки зависят не только от 
аппаратной конфигурации, но и от размера базы данных, числа соединений и сложность запросов, так что оптимально настроить базу данных 
возможно учитывая все эти параметры.

<H1><A NAME="SECTION00260000000000000000">
Оптимизация БД и приложения</A>
</H1>
Для быстрой работы каждого запроса в вашей базе в основном требуется следующее:

<OL>
<LI>Отсутствие в базе мусора, мешающего добраться до актуальных данных. Можно сформулировать две подзадачи:
 
<OL>
<LI>Грамотное проектирование базы. Освещение этого вопроса выходит далеко за рамки этой статьи.
</LI>
<LI>Сборка мусора, возникающего при работе СУБД.
 
</LI>
</OL>
</LI>
<LI>Наличие быстрых путей доступа к данным&nbsp;-- индексов.
</LI>
<LI>Возможность использования оптимизатором этих быстрых путей.
</LI>
<LI>Обход известных проблем.
</LI>
</OL>

<P>

<H2><A NAME="SECTION00261000000000000000">
Поддержание базы в порядке</A>
</H2>
В данном разделе описаны действия, которые должны периодически выполняться для каждой базы. От разработчика требуется только настроить 
их автоматическое выполнение (при помощи cron) и опытным путём подобрать его оптимальную частоту.

<P>

<H3><A NAME="SECTION00261100000000000000">
Команда ANALYZE</A>
</H3>
Служит для обновления информации о распределении данных в таблице. Эта информация используется оптимизатором для выбора наиболее 
быстрого плана выполнения запроса.

<P>
Обычно команда используется в связке VACUUM ANALYZE. Если в базе есть таблицы, данные в которых не изменяются и не удаляются, а лишь 
добавляются, то для таких таблиц можно использовать отдельную команду ANALYZE. Также стоит использовать эту команду для отдельной 
таблицы после добавления в неё большого количества записей.

<P>

<H3><A NAME="SECTION00261200000000000000">
Команда REINDEX</A>
</H3>
Команда REINDEX используется для перестройки существующих индексов.
Использовать её имеет смысл в случае:

<UL>
<LI>порчи индекса;
</LI>
<LI>постоянного увеличения его размера.
</LI>
</UL>

<P>
Второй случай требует пояснений. Индекс, как и таблица, содержит блоки со старыми версиями записей. PostgreSQL не всегда может 
заново использовать эти блоки, и поэтому файл с индексом постепенно увеличивается в размерах. Если данные в таблице часто меняются, 
то расти он может весьма быстро.

<P>
Если вы заметили подобное поведение какого-то индекса, то стоит настроить для него периодическое выполнение команды REINDEX. 
Учтите: команда REINDEX, как и VACUUM FULL, полностью блокирует таблицу, поэтому выполнять её надо тогда, когда загрузка 
сервера минимальна.

<P>

<H2><A NAME="SECTION00262000000000000000">
Использование индексов</A>
</H2>
Опыт показывает, что наиболее значительные проблемы с производительностью вызываются отсутствием нужных индексов. Поэтому столкнувшись 
с медленным запросом, в первую очередь проверьте, существуют ли индексы, которые он может использовать. Если нет&nbsp;-- постройте их.
Излишек индексов, впрочем, тоже чреват проблемами:

<UL>
<LI>Команды, изменяющие данные в таблице, должны изменить также и индексы. Очевидно, чем больше индексов построено для таблицы, 
тем медленнее это будет происходить.
</LI>
<LI>Оптимизатор перебирает возможные пути выполнения запросов. Если построено много ненужных индексов, то этот перебор будет 
идти дольше.
</LI>
</UL>
Единственное, что можно сказать с большой степенью определённости&nbsp;-- поля, являющиеся внешими ключами, и поля, по которым 
объединяются таблицы, индексировать надо обязательно.

<P>

<H3><A NAME="SECTION00262100000000000000">
Команда EXPLAIN [ANALYZE]</A>
</H3>
Команда EXPLAIN [запрос] показывает, каким образом PostgreSQL собирается выполнять ваш запрос. Команда EXPLAIN ANALYZE 
[запрос] выполняет запрос<A NAME="tex2html8"
  HREF="#foot533"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> и показывает как 
изначальный план, так и реальный процесс его выполнения.

<P>
Чтение вывода этих команд&nbsp;-- искусство, которое приходит с опытом. Для начала обращайте внимание на следующее:

<UL>
<LI>Использование полного просмотра таблицы (seq scan).
</LI>
<LI>Использование наиболее примитивного способа объединения таблиц (nested loop).
</LI>
<LI>Для EXPLAIN ANALYZE: нет ли больших отличий в предполагаемом количестве записей и реально выбранном? 
Если оптимизатор использует устаревшую статистику, то он может выбирать не самый быстрый план выполнения запроса.
</LI>
</UL>

<P>
Следует отметить, что полный просмотр таблицы далеко не всегда медленнее просмотра по индексу. Если, например, в 
таблице-справочнике несколько сотен записей, умещающихся в одном-двух блоках на диске, то использование индекса приведёт 
лишь к тому, что придётся читать ещё и пару лишних блоков индекса. Если в запросе придётся выбрать 80% записей из большой 
таблицы, то полный просмотр опять же получится быстрее.

<P>
При тестировании запросов с использованием EXPLAIN ANALYZE можно воспользоваться настройками, запрещающими оптимизатору использовать
определённые планы выполнения. Например,
<PRE>
SET enable_seqscan=false;
</PRE>

<P>
запретит использование полного просмотра таблицы, и вы сможете выяснить, прав ли был оптимизатор, отказываясь от использования 
индекса. Ни в коем случае не следует прописывать подобные команды в postgresql.conf! Это может ускорить выполнение нескольких запросов, 
но сильно замедлит все остальные!

<P>

<H3><A NAME="SECTION00262200000000000000">
Использование собранной статистики</A>
</H3>
Результаты работы сборщика статистики доступны через специальные системные представления. Наиболее интересны для 
наших целей следующие:

<UL>
<LI><SPAN  CLASS="textbf">pg_stat_user_tables</SPAN> содержит&nbsp;-- для каждой пользовательской таблицы в текущей базе данных&nbsp;-- общее количество 
полных просмотров и просмотров с использованием индексов, общие количества записей, которые были возвращены в результате обоих 
типов просмотра, а также общие количества вставленных, изменённых и удалённых записей.
</LI>
<LI><SPAN  CLASS="textbf">pg_stat_user_indexes</SPAN> содержит&nbsp;-- для каждого пользовательского индекса в текущей базе данных&nbsp;-- общее количество 
просмотров, использовавших этот индекс, количество прочитанных записей, количество успешно прочитанных записей в таблице (может быть 
меньше предыдущего значения, если в индексе есть записи, указывающие на устаревшие записи в таблице).
</LI>
<LI><SPAN  CLASS="textbf">pg_statio_user_tables</SPAN> содержит&nbsp;-- для каждой пользовательской таблицы в текущей базе данных&nbsp;-- общее количество 
блоков, прочитанных из таблицы, количество блоков, оказавшихся при этом в буфере (см. пункт 2.1.1), а также аналогичную статистику 
для всех индексов по таблице и, возможно, по связанной с ней таблицей TOAST.
</LI>
</UL>

<P>
Из этих представлений можно узнать, в частности

<UL>
<LI>Для каких таблиц стоит создать новые индексы (индикатором служит большое количество полных просмотров и большое количество 
прочитанных блоков).
</LI>
<LI>Какие индексы вообще не используются в запросах. Их имеет смысл удалить, если, конечно, речь не идёт об индексах, 
обеспечивающих выполнение ограничений PRIMARY KEY и UNIQUE.
</LI>
<LI>Достаточен ли объём буфера сервера.
</LI>
</UL>

<P>
Также возможен &#171;дедуктивный&#187; подход, при котором сначала создаётся большое количество индексов, а затем неиспользуемые индексы удаляются.

<P>

<H3><A NAME="SECTION00262300000000000000">
Возможности индексов в PostgreSQL</A>
</H3>
<SPAN  CLASS="textbf">Функциональные индексы</SPAN> Вы можете построить индекс не только по полю/нескольким полям таблицы, но и по выражению, зависящему от полей.
Пусть, например, в вашей таблице foo есть поле foo_name, и выборки часто делаются по условию 
&#171;первая буква foo_name = 'буква', в любом регистре&#187;.
Вы можете создать индекс
<PRE>
CREATE INDEX foo_name_first_idx 
ON foo ((lower(substr(foo_name, 1, 1))));
</PRE>
и запрос вида
<PRE>
SELECT * FROM foo 
WHERE lower(substr(foo_name, 1, 1)) = 'ы';
</PRE>
будет его использовать.

<P>
<SPAN  CLASS="textbf">Частичные индексы (partial indexes)</SPAN> Под частичным индексом понимается индекс с предикатом WHERE. Пусть, например, 
у вас есть в базе таблица scheta с параметром uplocheno типа boolean. Записей, где uplocheno = false меньше, чем записей 
с uplocheno = true, а запросы по ним выполняются значительно чаще. Вы можете создать индекс
<PRE>
CREATE INDEX scheta_neuplocheno ON scheta (id)
WHERE NOT uplocheno;
</PRE>
который будет использоваться запросом вида
<PRE>
SELECT * FROM scheta WHERE NOT uplocheno AND ...;
</PRE>
Достоинство подхода в том, что записи, не удовлетворяющие условию WHERE,
просто не попадут в индекс.

<P>

<H2><A NAME="SECTION00263000000000000000">
Перенос логики на сторону сервера</A>
</H2>
Этот пункт очевиден для опытных пользователей PostrgeSQL и предназначен для тех, кто использует или переносит на 
PostgreSQL приложения, написанные изначально для более примитивных СУБД.

<P>
Реализация части логики на стороне сервера через хранимые процедуры, триггеры, правила<A NAME="tex2html9"
  HREF="#foot558"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> часто позволяет ускорить 
работу приложения. Действительно, если несколько запросов объединены в процедуру, то не требуется

<UL>
<LI>пересылка промежуточных запросов на сервер;
</LI>
<LI>получение промежуточных результатов на клиент и их обработка.
</LI>
</UL>

<P>
Кроме того, хранимые процедуры упрощают процесс разработки и поддержки: изменения надо вносить только на стороне сервера, 
а не менять запросы во всех приложениях.

<P>

<H2><A NAME="SECTION00264000000000000000">
Оптимизация конкретных запросов</A>
</H2>
В этом разделе описываются запросы, для которых по разным причинам нельзя заставить оптимизатор использовать индексы, и 
которые будут всегда вызывать полный просмотр таблицы. Таким образом, если вам требуется использовать эти запросы в 
требовательном к быстродействию приложении, то придётся их изменить.

<P>

<H3><A NAME="SECTION00264100000000000000">
SELECT count(*) FROM &lt;огромная таблица&gt;</A>
</H3>
К функции count() относится всё вышесказанное по поводу реализации агрегатных функций в PostgreSQL. Кроме того, 
информация о видимости записи для текущей транзакции (а конкурентным транзакциям может быть видимо разное
количество записей в таблице!) не хранится в индексе. Таким образом, даже если использовать для выполнения 
запроса индекс первичного ключа таблицы, всё равно потребуется чтение записей собственно из файла таблицы.

<P>
<SPAN  CLASS="textbf">Проблема</SPAN> Запрос вида
<PRE>
SELECT count(*) FROM foo;
</PRE>
осуществляет полный просмотр таблицы foo, что весьма долго для таблиц с большим количеством записей.

<P>
<SPAN  CLASS="textbf">Решение</SPAN> Простого решения проблемы, к сожалению, нет. Возможны следу-
ющие подходы:

<OL>
<LI>Если точное число записей не важно, а важен порядок<A NAME="tex2html10"
  HREF="#foot568"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>, то можно использовать информацию о количестве 
записей в таблице, собранную при выполнении команды ANALYZE:
<PRE>
SELECT reltuples FROM pg_class WHERE relname = 'foo';
</PRE>
</LI>
<LI>Если подобные выборки выполняются часто, а изменения в таблице достаточно редки, то можно завести вспомогательную 
таблицу, хранящую число записей в основной. На основную же таблицу повесить триггер, который будет уменьшать это число 
в случае удаления записи и увеличивать в случае вставки. Таким образом, для получения количества записей потребуется лишь 
выбрать одну запись из вспомогательной таблицы.
</LI>
<LI>Вариант предыдущего подхода, но данные во вспомогательной таблице обновляются через определённые промежутки времени (cron).
</LI>
</OL>

<P>

<H3><A NAME="SECTION00264200000000000000">
Медленый DISTINCT</A>
</H3>
Текущая реализация DISTINCT для больших таблиц очень медленна. Но возможно использовать GROUP BY взамен DISTINCT. 
GROUP BY может использовать агрегирующий хэш, что значительно быстрее, чем DISTINCT.
<PRE>
DISTINCT

postgres=# select count(*) from (select distinct i from g) a;
 count 
-------
 19125
(1 row)

Time: 580,553 ms

Второй раз:
postgres=# select count(*) from (select distinct i from g) a;
 count 
-------
 19125
(1 row)

Time: 36,281 ms


GROUP BY

postgres=# select count(*) from (select i from g group by i) a;
 count 
-------
 19125
(1 row)

Time: 26,562 ms

Второй раз:
postgres=# select count(*) from (select i from g group by i) a;
 count 
-------
 19125
(1 row)

Time: 25,270 ms
</PRE>

<P>

<H2><A NAME="SECTION00265000000000000000">
Оптимизация запросов с помощью pgFouine</A>
</H2>
pgFouine<A NAME="tex2html11"
  HREF="#foot576"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- это 
анализатор log-файлов для PostgreSQL, используемый для генерации детальных отчетов из 
log-файлов PostgreSQL. pgFouine поможет определить, какие запросы следует оптимизировать в первую очередь.
pgFouine написан на языке программирования PHP с использованием объектно-ориентированных технологий и легко 
расширяется для поддержки специализированных отчетов, является свободным программным обеспечением и 
распространяется на условиях GNU General Public License. Утилита спроектирована таким образом, чтобы обработка 
очень больших log-файлов не требовала много ресурсов.

<P>
Для работы с pgFouine сначала нужно сконфигурировать PostgreSQL для создания нужного формата log-файлов:

<UL>
<LI>Чтобы включить протоколирование в syslog
<PRE>
log_destination = 'syslog'
redirect_stderr = off
silent_mode = on
</PRE>
</LI>
<LI>Для записи запросов, длящихся дольше n миллисекунд:
<PRE>
log_min_duration_statement = n
log_duration = off
log_statement = 'none'
</PRE>
</LI>
</UL>

<P>
Для записи каждого обработанного запроса установите log_min_duration_statement на 0. 
Чтобы отключить запись запросов, установите этот параметр на -1.

<P>
pgFouine&nbsp;-- простой в использовании инструмент командной строки. Следующая команда создаёт 
HTML-отчёт со стандартными параметрами:
<PRE>
$pgfouine.php -file your/log/file.log &gt; your-report.html
</PRE>

<P>
С помощью этой строки можно отобразить текстовый отчёт с 10 запросами на каждый экран на стандартном выводе:
<PRE>
$ pgfouine.php -file your/log/file.log -top 10 -format text
</PRE>

<P>
Более подробно о возможностях, а также много полезных примеров, можно найти на официальном сайта проекта&nbsp;-- 
http://pgfouine.projects.postgresql.org.

<P>

<H1><A NAME="SECTION00270000000000000000">
Заключение</A>
</H1>
К счастью, PostgreSQL не требует особо сложной настройки. В большинстве случаев вполне достаточно будет увеличить 
объём выделенной памяти, настроить периодическое поддержание базы в порядке и проверить наличие необходимых индексов. 
Более сложные вопросы можно обсудить в специализированном списке рассылки.

<H1><A NAME="SECTION00300000000000000000">
Репликация</A>
</H1>

<H1><A NAME="SECTION00310000000000000000">
Введение</A>
</H1>
Репликация (англ. replication)&nbsp;-- механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных). 
Репликация&nbsp;-- это процесс, под которым понимается копирование данных из одного источника на множество других и наоборот.
При репликации изменения, сделанные в одной копии объекта, могут быть распространены в другие копии. Репликация может быть 
синхронной или асинхронной.

<P>
В случае синхронной репликации, если данная реплика обновляется, все другие реплики того же фрагмента данных 
также должны быть обновлены в одной и той же транзакции. Логически это означает, что существует лишь одна версия данных.
В большинстве продуктов синхронная репликация реализуется с помощью триггерных процедур (возможно, скрытых и управляемых системой). 
Но синхронная репликация имеет тот недостаток, что она создаёт дополнительную нагрузку при выполнении всех транзакций, 
в которых обновляются какие-либо реплики (кроме того, могут возникать проблемы, связанные с доступностью данных).

<P>
В случае асинхронной репликации обновление одной реплики распространяется на другие спустя некоторое время, 
а не в той же транзакции. Таким образом, при асинхронной репликации вводится задержка, или время ожидания, в течение которого 
отдельные реплики могут быть фактически неидентичными (то есть определение реплика оказывается не совсем подходящим, 
поскольку мы не имеем дело с точными и своевременно созданными копиями).
В большинстве продуктов асинхронная репликация реализуется посредством чтения журнала транзакций или постоянной очереди 
тех обновлений, которые подлежат распространению. Преимущество асинхронной репликации состоит в том, что 
дополнительные издержки репликации не связаны с транзакциями обновлений, которые могут иметь важное значение 
для функционирования всего предприятия и предъявлять высокие требования к производительности.
К недостаткам этой схемы относится то, что данные могут оказаться несовместимыми (то есть несовместимыми с точки зрения 
пользователя). Иными словами, избыточность может проявляться на логическом уровне, а это, строго говоря, означает, 
что термин контролируемая избыточность в таком случае не применим.

<P>
Рассмотрим кратко проблему согласованности (или, скорее, несогласованности). 
Дело в том, что реплики могут становиться несовместимыми в результате ситуаций, которые трудно (или даже 
невозможно) избежать и последствия которых трудно исправить.
В частности, конфликты могут возникать по поводу того, в каком порядке должны применяться обновления. 
Например, предположим, что в результате выполнения транзакции А происходит вставка строки в реплику X, 
после чего транзакция B удаляет эту строку, а также допустим, что Y&nbsp;-- реплика X. Если обновления распространяются на Y, 
но вводятся в реплику Y в обратном порядке (например, из-за разных задержек при передаче), то транзакция B не находит в Y 
строку, подлежащую удалению, и не выполняет своё действие, после чего транзакция А вставляет эту строку. Суммарный эффект 
состоит в том, что реплика Y содержит указанную строку, а реплика X&nbsp;-- нет.

<P>
В целом задачи устранения конфликтных ситуаций и обеспечения согласованности реплик являются весьма сложными. 
Следует отметить, что, по крайней мере, в сообществе пользователей коммерческих баз данных термин репликация стал означать 
преимущественно (или даже исключительно) асинхронную репликацию.

<P>
Основное различие между репликацией и управлением копированием заключается в следующем:
Если используется репликация, то обновление одной реплики в конечном счёте распространяется на все остальные автоматически.
В режиме управления копированием, напротив, не существует такого автоматического распространения обновлений. 
Копии данных создаются и управляются с помощью пакетного или фонового процесса, который отделён во времени от транзакций обновления.
Управление копированием в общем более эффективно по сравнению с репликацией, поскольку за один раз могут копироваться 
большие объёмы данных. К недостаткам можно отнести то, что большую часть времени копии данных не идентичны базовым данным, 
поэтому пользователи должны учитывать, когда именно были синхронизированы эти данные.
Обычно управление копированием упрощается благодаря тому требованию, чтобы обновления применялись в соответствии со 
схемой первичной копии того или иного вида.

<P>
Для репликации PostgreSQL существует несколько решений, как закрытых, так и свободных. 
Закрытые системы репликации не будут рассматриваться в этой книге (ну, сами понимаете). Вот список свободных решений:

<UL>
<LI><SPAN  CLASS="textbf">Slony-I</SPAN><A NAME="tex2html12"
  HREF="#foot664"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- асинхронная Master-Slave репликация, 
поддерживает каскады(cascading) и отказоустойчивость(failover). 
Slony-I использует триггеры PostgreSQL для привязки к событиям INSERT/ DELETE/UPDATE и хранимые 
процедуры для выполнения действий. 

<P>
</LI>
<LI><SPAN  CLASS="textbf">PGCluster</SPAN><A NAME="tex2html13"
  HREF="#foot666"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- синхронная Multi-Master репликация. 
Проект на мой взгляд мертв, поскольку уже год не обновлялся.

<P>
</LI>
<LI><SPAN  CLASS="textbf">pgpool-I/II</SPAN><A NAME="tex2html14"
  HREF="#foot668"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- это замечательная тулза для 
PostgreSQL (лучше сразу работать с II версией). Позволяет делать:

<UL>
<LI>репликацию (в том числе, с автоматическим переключением на резервный stand-by сервер);
</LI>
<LI>online-бэкап;
</LI>
<LI>pooling коннектов;
</LI>
<LI>очередь соединений;
</LI>
<LI>балансировку SELECT-запросов на несколько postgresql-серверов;
</LI>
<LI>разбивать запросы, для параллельного выполнения над большими объемами данных.
</LI>
</UL>

<P>
</LI>
<LI><SPAN  CLASS="textbf">Bucardo</SPAN><A NAME="tex2html15"
  HREF="#foot672"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- асинхронная репликация, которая поддерживает Multi-Master и Master-Slave режимы, 
а также несколько видов синхронизации и обработки конфликтов. 

<P>
</LI>
<LI><SPAN  CLASS="textbf">Londiste</SPAN><A NAME="tex2html16"
  HREF="#foot674"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- асинхронная Master-Slave 
репликация. Входит в состав Skytools<A NAME="tex2html17"
  HREF="#foot675"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>. Проще в использовании, чем Slony-I.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Mammoth Replicator</SPAN><A NAME="tex2html18"
  HREF="#foot677"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- асинхронная 
Multi-Master репликация. 

<P>
</LI>
<LI><SPAN  CLASS="textbf">Postgres-R</SPAN><A NAME="tex2html19"
  HREF="#foot679"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- асинхронная Multi-Master репликация.

<P>
</LI>
<LI><SPAN  CLASS="textbf">RubyRep</SPAN><A NAME="tex2html20"
  HREF="#foot681"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>&nbsp;-- написаная на Ruby, асинхронная Multi-Master 
репликация, которая поддерживает PostgreSQL и MySQL.
</LI>
</UL>

<P>
Это конечно не весь список свободных систем для репликации, но я думаю даже из этого есть что выбрать для PostgreSQL.

<H1><A NAME="SECTION00320000000000000000">
Slony-I</A>
</H1>

<H2><A NAME="SECTION00321000000000000000">
Введение</A>
</H2>
Slony это система репликации реального времени, позволяющая организовать синхронизацию нескольких серверов 
PostgreSQL по сети. Slony использует триггеры Postgre для привязки к событиям INSERT/ DELETE/UPDATE и 
хранимые процедуры для выполнения действий.

<P>
Система Slony с точки зрения администратора состоит из двух главных компонент, репликационного демона slony и 
административной консоли slonik. Администрирование системы сводится к общению со slonik-ом, демон slon только 
следит за собственно процессом репликации. А админ следит за тем, чтобы slon висел там, где ему положено. 

<P>

<H3><A NAME="SECTION00321100000000000000">
О slonik-e</A>
</H3>
Все команды slonik принимает на свой stdin. До начала выполнения скрипт slonik-a проверяется на соответствие синтаксису, 
если обнаруживаются ошибки, скрипт не выполняется, так что можно не волноваться если slonik сообщает о syntax error, 
ничего страшного не произошло. И он ещё ничего не сделал. Скорее всего. 

<P>

<H2><A NAME="SECTION00322000000000000000">
Установка</A>
</H2>
Установка на Ubuntu производится простой командой:
<PRE>
sudo aptitude install slony1-bin
</PRE>

<P>

<H2><A NAME="SECTION00323000000000000000"></A>
<A NAME="sec:slonyI"></A>
<BR>
Настройка
</H2>
Рассмотрим теперь установку на гипотетическую базу данных customers 
(названия узлов, кластеров и таблиц являются вымышленными).

<P>
Наши данные

<UL>
<LI>БД: customers
</LI>
<LI>master_host: customers_master.com
</LI>
<LI>slave_host_1: customers_slave.com
</LI>
<LI>cluster name (нужно придумать): customers_rep
</LI>
</UL>

<P>

<H3><A NAME="SECTION00323100000000000000">
Подготовка master-сервера</A>
</H3>
Для начала нам нужно создать пользователя Postgres, под которым будет действовать Slony. 
По умолчанию, и отдавая должное системе, этого пользователя обычно называют slony.
<PRE>
pgsql@customers_master$ createuser -a -d slony
pgsql@customers_master$ psql -d template1 -c "alter \
user slony with password 'slony_user_password';"
</PRE>

<P>
Также на каждом из узлов лучше завести системного пользователя slony, чтобы запускать от его имени 
репликационного демона slon. В дальнейшем подразумевается, что он (и пользователь и slon) есть на 
каждом из узлов кластера. 

<P>

<H3><A NAME="SECTION00323200000000000000">
Подготовка одного slave-сервера</A>
</H3>
Здесь я рассматриваю, что серверы кластера соединены посредством сети Internet (как в моём случае), необходимо 
чтобы с каждого из ведомых серверов можно было установить соединение с PostgreSQL на мастер-хосте, и наоборот. 
То есть, команда:
<PRE>
anyuser@customers_slave$ psql -d customers \
-h customers_master.com -U slony
</PRE>

<P>
должна подключать нас к мастер-серверу (после ввода пароля, желательно). Если что-то не так, возможно требуется 
поковыряться в настройках firewall-a, или файле pg_hba.conf, который лежит в $PGDATA.

<P>
Теперь устанавливаем на slave-хост сервер PostgreSQL. Следующего обычно не требуется, сразу после установки Postgres 
&#171;up and ready&#187;, но в случае каких-то ошибок можно начать &#171;с чистого листа&#187;, выполнив следующие команды 
(предварительно сохранив конфигурационные файлы и остановив postmaster):
<PRE>
pgsql@customers_slave$ rm -rf $PGDATA
pgsql@customers_slave$ mkdir $PGDATA
pgsql@customers_slave$ initdb -E UTF8 -D $PGDATA
pgsql@customers_slave$ createuser -a -d slony
pgsql@customers_slave$ psql -d template1 -c "alter \
user slony with password 'slony_user_password';"
</PRE>

<P>
Запускаем postmaster.

<P>
Внимание! Обычно требуется определённый владелец для реплицируемой БД. В этом случае необходимо завести его тоже!
<PRE>
pgsql@customers_slave$ createuser -a -d customers_owner
pgsql@customers_slave$ psql -d template1 -c "alter \
user customers_owner with password 'customers_owner_password';"
</PRE>

<P>
Эти две команды можно запускать с customers_master, к командной строке в этом случае нужно добавить 
&#171;-h customers_slave&#187;, чтобы все операции выполнялись на slave.

<P>
На slave, как и на master, также нужно установить Slony.

<P>

<H3><A NAME="SECTION00323300000000000000">
Инициализация БД и plpgsql на slave</A>
</H3>

<P>
Следующие команды выполняются от пользователя slony. Скорее всего для выполнения каждой из них потребуется 
ввести пароль (slony_user_password). Итак:
<PRE>
slony@customers_master$ createdb -O customers_owner \
-h customers_slave.com customers
slony@customers_master$ createlang -d customers \
-h customers_slave.com plpgsql
</PRE>

<P>
Внимание! Все таблицы, которые будут добавлены в replication set должны иметь primary key. 
Если какая-то из таблиц не удовлетворяет этому условию, задержитесь на этом шаге и дайте каждой таблице primary key 
командой ALTER TABLE ADD PRIMARY KEY.

<P>
Если столбца который мог бы стать primary key не находится, добавьте новый столбец типа serial (ALTER TABLE ADD COLUMN), 
и заполните его значениями. Настоятельно НЕ рекомендую использовать &#171;table add key&#187; slonik-a.

<P>
Продолжаем.
Создаём таблицы и всё остальное на slave:
<PRE>
slony@customers_master$ pg_dump -s customers | \
psql -U slony -h customers_slave.com customers
</PRE>

<P>
pg_dump -s сдампит только структуру нашей БД.

<P>
pg_dump -s customers должен пускать без пароля, а вот для psql -U slony -h customers_slave.com 
customers придётся набрать пароль (slony_user_pass). Важно: я подразумеваю что сейчас на мастер-хосте 
ещё не установлен Slony (речь не про make install), то есть в БД нет таблиц sl_*, триггеров и прочего. 
Если есть, то возможно два варианта:

<UL>
<LI>добавляется узел в уже функционирующую систему репликации (читайте раздел 5)
</LI>
<LI>это ошибка :-) Тогда до переноса структуры на slave выполните следующее:
<PRE>
slonik &lt;&lt;EOF
cluster name = customers_slave;
node Y admin conninfo = 'dbname=customers host=customers_master.com 
port=5432 user=slony password=slony_user_pass';
uninstall node (id = Y);
echo 'okay';
EOF
</PRE>
Y&nbsp;-- число. Любое. Важно: если это действительно ошибка, cluster name может иметь какой-то другое значение, например T1 
(default). Нужно его выяснить и сделать uninstall.

<P>
Если структура уже перенесена (и это действительно ошибка), сделайте uninstall с обоих узлов (с master и slave). 
</LI>
</UL>

<P>

<H3><A NAME="SECTION00323400000000000000">
Инициализация кластера</A>
</H3>
Если Сейчас мы имеем два сервера PgSQL которые свободно &#171;видят&#187; друг друга по сети, 
на одном из них находится мастер-база с данными, на другом&nbsp;-- только структура.

<P>
На мастер-хосте запускаем такой скрипт:
<PRE>
#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME2=customers

HOST1=customers_master.com
HOST2=customers_slave.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik &lt;&lt;EOF
cluster name = $CLUSTER;
node 1 admin conninfo = 'dbname=$DBNAME1 host=$HOST1 port=$PORT1 
user=slony password=slony_user_password';
node 2 admin conninfo = 'dbname=$DBNAME2 host=$HOST2 
port=$PORT2 user=slony password=slony_user_password';
init cluster ( id = 1, comment = 'Customers DB 
replication cluster' );

echo 'Create set';

create set ( id = 1, origin = 1, comment = 'Customers 
DB replication set' );

echo 'Adding tables to the subscription set';

echo ' Adding table public.customers_sales...';
set add table ( set id = 1, origin = 1, id = 4, full qualified 
name = 'public.customers_sales', comment = 'Table public.customers_sales' );
echo ' done';

echo ' Adding table public.customers_something...';
set add table ( set id = 1, origin = 1, id = 5, full qualified 
name = 'public.customers_something, 
comment = 'Table public.customers_something );
echo ' done';

echo 'done adding';
store node ( id = 2, comment = 'Node 2, $HOST2' );
echo 'stored node';
store path ( server = 1, client = 2, conninfo = 'dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_password' );
echo 'stored path';
store path ( server = 2, client = 1, conninfo = 'dbname=$DBNAME2 host=$HOST2 
port=$PORT2 user=slony password=slony_user_password' );

store listen ( origin = 1, provider = 1, receiver = 2 );
store listen ( origin = 2, provider = 2, receiver = 1 );
EOF
</PRE>

<P>
Здесь мы инициализируем кластер, создаём репликационный набор, включаем в него две таблицы. 
Важно: нужно перечислить все таблицы, которые нужно реплицировать, id таблицы в наборе должен быть уникальным, 
таблицы должны иметь primary key.

<P>
Важно: replication set запоминается раз и навсегда. Чтобы добавить узел в схему репликации не нужно заново инициализировать set.

<P>
Важно: если в набор добавляется или удаляется таблица нужно переподписать все узлы. 
То есть сделать unsubscribe и subscribe заново. 

<P>

<H3><A NAME="SECTION00323500000000000000">
Подписываем slave-узел на replication set</A>
</H3>
Скрипт:
<PRE>
#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME2=customers

HOST1=customers_master.com
HOST2=customers_slave.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik &lt;&lt;EOF
cluster name = $CLUSTER;
node 1 admin conninfo = 'dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_password';
node 2 admin conninfo = 'dbname=$DBNAME2 host=$HOST2 
port=$PORT2 user=slony password=slony_user_password';

echo'subscribing';
subscribe set ( id = 1, provider = 1, receiver = 2, forward = no);

EOF
</PRE>

<P>

<H3><A NAME="SECTION00323600000000000000">
Старт репликации</A>
</H3>
Теперь, на обоих узлах необходимо запустить демона репликации.
<PRE>
slony@customers_master$ slon customers_rep \
"dbname=customers user=slony"
</PRE>

<P>
и
<PRE>
slony@customers_slave$ slon customers_rep \
"dbname=customers user=slony"
</PRE>

<P>
Сейчас слоны обменяются сообщениями и начнут передачу данных. Начальное наполнение происходит с помощью COPY, 
slave DB на это время полностью блокируется.

<P>
В среднем время актуализации данных на slave-системе составляет до 10-ти секунд. 
slon успешно обходит проблемы со связью и подключением к БД, и вообще требует к 
себе достаточно мало внимания. 

<P>

<H2><A NAME="SECTION00324000000000000000">
Общие задачи</A>
</H2>

<H3><A NAME="SECTION00324100000000000000">
Добавление ещё одного узла в работающую схему репликации</A>
</H3>
Выполнить&nbsp;<A HREF="#sec:slonyI">2.2</A>.1 и выполнить&nbsp;<A HREF="#sec:slonyI">2.2</A>.2.

<P>
Новый узел имеет id = 3. Находится на хосте customers_slave3.com, &#171;видит&#187; мастер-сервер по сети и 
мастер может подключиться к его PgSQL. 

<P>
после дублирования структуры (п&nbsp;<A HREF="#sec:slonyI">2.2</A>.2) делаем следующее:
<PRE>
slonik &lt;&lt;EOF
cluster name = customers_slave;
node 3 admin conninfo = 'dbname=customers host=customers_slave3.com 
port=5432 user=slony password=slony_user_pass';
uninstall node (id = 3);
echo 'okay';
EOF
</PRE>

<P>
Это нужно чтобы удалить схему, триггеры и процедуры, которые были сдублированы вместе с таблицами и структурой БД.

<P>
Инициализировать кластер не надо. Вместо этого записываем информацию о новом узле в сети:
<PRE>
#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME3=customers

HOST1=customers_master.com
HOST3=customers_slave3.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik &lt;&lt;EOF
cluster name = $CLUSTER;
node 1 admin conninfo = 'dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_pass';
node 3 admin conninfo = 'dbname=$DBNAME3 
host=$HOST3 port=$PORT2 user=slony password=slony_user_pass';

echo 'done adding';

store node ( id = 3, comment = 'Node 3, $HOST3' );
echo 'sored node';
store path ( server = 1, client = 3, conninfo = 'dbname=$DBNAME1 
host=$HOST1 port=$PORT1 user=slony password=slony_user_pass' );
echo 'stored path';
store path ( server = 3, client = 1, conninfo = 'dbname=$DBNAME3 
host=$HOST3 port=$PORT2 user=slony password=slony_user_pass' );

echo 'again';
store listen ( origin = 1, provider = 1, receiver = 3 );
store listen ( origin = 3, provider = 3, receiver = 1 );

EOF
</PRE>

<P>
Новый узел имеет id 3, потому что 2 уже есть и работает. Подписываем новый узел 3 на replication set:
<PRE>
#!/bin/sh

CLUSTER=customers_rep

DBNAME1=customers
DBNAME3=customers

HOST1=customers_master.com
HOST3=customers_slave3.com

PORT1=5432
PORT2=5432

SLONY_USER=slony

slonik &lt;&lt;EOF
cluster name = $CLUSTER;
node 1 admin conninfo = 'dbname=$DBNAME1 host=$HOST1 
port=$PORT1 user=slony password=slony_user_pass';
node 3 admin conninfo = 'dbname=$DBNAME3 host=$HOST3 
port=$PORT2 user=slony password=slony_user_pass';

echo'subscribing';
subscribe set ( id = 1, provider = 1, receiver = 3, forward = no);

EOF
</PRE>

<P>
Теперь запускаем slon на новом узле, так же как и на остальных. Перезапускать slon на мастере не надо.
<PRE>
slony@customers_slave3$ slon customers_rep \
"dbname=customers user=slony"
</PRE>

<P>
Репликация должна начаться как обычно. 

<P>

<H2><A NAME="SECTION00325000000000000000">
Устранение неисправностей</A>
</H2>

<H3><A NAME="SECTION00325100000000000000">
Ошибка при добавлении узла в систему репликации</A>
</H3>
Периодически, при добавлении новой машины в кластер возникает следующая ошибка: на новой ноде всё начинает 
жужжать и работать, имеющиеся же отваливаются с примерно следующей диагностикой:
<PRE>
%slon customers_rep "dbname=customers user=slony_user"
CONFIG main: slon version 1.0.5 starting up
CONFIG main: local node id = 3
CONFIG main: loading current cluster configuration
CONFIG storeNode: no_id=1 no_comment='CustomersDB 
replication cluster'
CONFIG storeNode: no_id=2 no_comment='Node 2, 
node2.example.com'
CONFIG storeNode: no_id=4 no_comment='Node 4, 
node4.example.com'
CONFIG storePath: pa_server=1 pa_client=3 
pa_conninfo="dbname=customers 
host=mainhost.com port=5432 user=slony_user 
password=slony_user_pass" pa_connretry=10
CONFIG storeListen: li_origin=1 li_receiver=3 
li_provider=1
CONFIG storeSet: set_id=1 set_origin=1 
set_comment='CustomersDB replication set'
WARN remoteWorker_wakeup: node 1 - no worker thread
CONFIG storeSubscribe: sub_set=1 sub_provider=1 sub_forward='f'
WARN remoteWorker_wakeup: node 1 - no worker thread
CONFIG enableSubscription: sub_set=1
WARN remoteWorker_wakeup: node 1 - no worker thread
CONFIG main: configuration complete - starting threads
CONFIG enableNode: no_id=1
CONFIG enableNode: no_id=2
CONFIG enableNode: no_id=4
ERROR remoteWorkerThread_1: "begin transaction; set 
transaction isolation level 
serializable; lock table "_customers_rep".sl_config_lock; select 
"_customers_rep".enableSubscription(1, 1, 4); 
notify "_customers_rep_Event"; notify "_customers_rep_Confirm"; 
insert into "_customers_rep".sl_event (ev_origin, ev_seqno, 
ev_timestamp, ev_minxid, ev_maxxid, ev_xip, 
ev_type , ev_data1, ev_data2, ev_data3, ev_data4 ) values 
('1', '219440', 
'2005-05-05 18:52:42.708351', '52501283', '52501292', 
'''52501283''', 'ENABLE_SUBSCRIPTION', 
'1', '1', '4', 'f'); insert into "_customers_rep".
sl_confirm (con_origin, con_received, 
con_seqno, con_timestamp) values (1, 3, '219440', 
CURRENT_TIMESTAMP); commit transaction;" 
PGRES_FATAL_ERROR ERROR: insert or update on table 
"sl_subscribe" violates foreign key 
constraint "sl_subscribe-sl_path-ref"
DETAIL: Key (sub_provider,sub_receiver)=(1,4) 
is not present in table "sl_path".
INFO remoteListenThread_1: disconnecting from 
'dbname=customers host=mainhost.com 
port=5432 user=slony_user password=slony_user_pass'
%
</PRE>

<P>
Это означает что в служебной таблице _&lt;имя кластера&gt;.sl_path;, например 
_customers_rep.sl_path на уже имеющихся узлах отсутствует информация о новом узле. В данном случае, 
id нового узла 4, пара (1,4) в sl_path отсутствует.

<P>
Видимо, это баг Slony. Как избежать этого и последующих ручных вмешательств пока не ясно.

<P>
Чтобы это устранить, нужно выполнить на каждом из имеющихся узлов приблизительно следующий запрос 
(добавить путь, в данном случае (1,4)):
<PRE>
slony_user@masterhost$ psql -d customers -h _every_one_of_slaves -U slony
customers=# insert into _customers_rep.sl_path 
values ('1','4','dbname=customers host=mainhost.com 
port=5432 user=slony_user password=slony_user_password,'10');
</PRE>

<P>
Если возникают затруднения, да и вообще для расширения кругозора можно посмотреть на служебные таблицы 
и их содержимое. Они не видны обычно и находятся в рамках пространства имён _&lt;имя кластера&gt;, 
например _customers_rep. 

<P>

<H3><A NAME="SECTION00325200000000000000">
Что делать если репликация со временем начинает тормозить</A>
</H3>
В процессе эксплуатации наблюдаю как со временем растёт нагрузка на master-сервере, в списке активных бекендов&nbsp;-- 
постоянные SELECT-ы со слейвов. В pg_stat_activity видим примерно такие запросы:
<PRE>
select ev_origin, ev_seqno, ev_timestamp, ev_minxid, ev_maxxid, ev_xip, 
ev_type, ev_data1, ev_data2, ev_data3, ev_data4, ev_data5, ev_data6, 
ev_data7, ev_data8 from "_customers_rep".sl_event e where 
(e.ev_origin = '2' and e.ev_seqno &gt; '336996') or 
(e.ev_origin = '3' and e.ev_seqno &gt; '1712871') or 
(e.ev_origin = '4' and e.ev_seqno &gt; '721285') or 
(e.ev_origin = '5' and e.ev_seqno &gt; '807715') or 
(e.ev_origin = '1' and e.ev_seqno &gt; '3544763') or 
(e.ev_origin = '6' and e.ev_seqno &gt; '2529445') or 
(e.ev_origin = '7' and e.ev_seqno &gt; '2512532') or 
(e.ev_origin = '8' and e.ev_seqno &gt; '2500418') or 
(e.ev_origin = '10' and e.ev_seqno &gt; '1692318') 
order by e.ev_origin, e.ev_seqno;
</PRE>

<P>
Не забываем что _customers_rep&nbsp;-- имя схемы из примера, у вас будет другое имя.

<P>
Таблица sl_event почему-то разрастается со временем, замедляя выполнение этих 
запросов до неприемлемого времени. Удаляем ненужные записи:
<PRE>
delete from _customers_rep.sl_event where 
ev_timestamp&lt;NOW()-'1 DAY'::interval;
</PRE>

<P>
Производительность должна вернуться к изначальным значениям. 
Возможно имеет смысл почистить таблицы _customers_rep.sl_log_* где 
вместо звёздочки подставляются натуральные числа, по-видимому по 
количеству репликационных сетов, так что _customers_rep.sl_log_1 
точно должна существовать. 

<H1><A NAME="SECTION00330000000000000000">
Londiste</A>
</H1>

<H2><A NAME="SECTION00331000000000000000">
Введение</A>
</H2>
Londiste представляет собой движок для организации репликации, написанный на языке python. 
Основные принципы: надежность и простота использования. Из-за этого данное решение имеет меньше функциональности, 
чем Slony-I. Londiste использует в качестве транспортного механизма очередь PgQ  (описание этого более чем интересного 
проекта остается за рамками данной главы, поскольку он представляет интерес скорее для низкоуровневых программистов 
баз данных, чем для конечных пользователей&nbsp;-- администраторов СУБД PostgreSQL). Отличительными особенностями решения являются:

<UL>
<LI>возможность потабличной репликации
</LI>
<LI>начальное копирование ничего не блокирует
</LI>
<LI>возможность двухстороннего сравнения таблиц
</LI>
<LI>простота установки
</LI>
</UL>

<P>
К недостаткам можно отнести:

<UL>
<LI>отсутствие поддержки каскадной репликации, отказоустойчивости(failover) и переключение между 
серверами (switchover) (все это обещают к 3 версии реализовать
<A NAME="tex2html21"
  HREF="#foot896"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>)
</LI>
</UL>

<P>

<H2><A NAME="SECTION00332000000000000000">
Установка</A>
</H2>
На серверах, которые мы настраиваем расматривается ОС Linux, а именно Ubuntu Server. 
Автор данной книги считает, что под другие операционные системы (кроме Windows) все мало чем будет отличаться, 
а держать кластера PostgreSQL под ОС Windows, по меньшей мере, неразумно.

<P>
Поскольку Londiste&nbsp;-- это часть Skytools, то нам нужно ставить этот пакет. На таких системах, как Debian или Ubuntu skytools 
можно найти в репозитории пакетов и поставить одной командой:
<PRE>
$sudo aptitude install skytools
</PRE>

<P>
Но все же лучше скачать самую последнюю версию пакета с официального сайта&nbsp;-- http://pgfoundry.org/projects/skytools. 
На момент написания статьи последняя версия была 2.1.11. Итак, начнем:

<P>
<PRE>
$wget http://pgfoundry.org/frs/download.php/2561/
skytools-2.1.11.tar.gz
$tar zxvf skytools-2.1.11.tar.gz
$cd skytools-2.1.11/
# это для сборки deb пакета
$sudo aptitude install build-essential autoconf \ 
automake autotools-dev dh-make \ 
debhelper devscripts fakeroot xutils lintian pbuilder \
python-dev yada
# ставим пакет исходников для postgresql 8.4.x
$sudo aptitude install postgresql-server-dev-8.4
# python-psycopg нужен для работы Londiste
$sudo aptitude install python-psycopg2
# данной командой я собираю deb пакет для 
# postgresql 8.4.x (для 8.3.x например будет "make deb83")
$sudo make deb84
$cd ../
# ставим skytools
$dpkg -i skytools-modules-8.4_2.1.11_i386.deb 
skytools_2.1.11_i386.deb
</PRE>

<P>
Для других систем можно собрать Skytools командами 

<P>
<PRE>
$./configure
$make
$make install
</PRE>

<P>
Дальше проверим, что все у нас правильно установилось
<PRE>
$londiste.py -V
Skytools version 2.1.11
$pgqadm.py -V
Skytools version 2.1.11
</PRE>

<P>
Если у Вас похожий вывод, значит все установленно правильно и можно приступать к настройке.

<P>

<H2><A NAME="SECTION00333000000000000000">
Настройка</A>
</H2>
Обозначения: 

<UL>
<LI>host1&nbsp;-- мастер; 
</LI>
<LI>host2&nbsp;-- слейв;
</LI>
</UL>

<P>

<H3><A NAME="SECTION00333100000000000000">
Настройка ticker-а</A>
</H3>
Londiste требуется ticker для работы с мастер базой данных, который может быть запущен и на другой машине. 
Но, конечно, лучше его запускать на той же, где и мастер база данных. Для этого мы настраиваем специальный 
конфиг для ticker-а (пусть конфиг будет у нас /etc/skytools/db1-ticker.ini):
<PRE>
[pgqadm]
# название
job_name = db1-ticker

# мастер база данных 
db = dbname=P host=host1 

# Задержка между запусками обслуживания 
# (ротация очередей и т.п.) в секундах
maint_delay = 600

# Задержка между проверками наличия активности 
# (новых пакетов данных) в секундах
loop_delay = 0.1

# log и pid демона
logfile = /var/log/%(job_name)s.log
pidfile = /var/pid/%(job_name)s.pid
</PRE>

<P>
Теперь необходимо инсталлировать служебный код (SQL) и запустить ticker как демона для базы данных. 
Делается это с помощью утилиты pgqadm.py следующими командами:
<PRE>
pgqadm.py /etc/skytools/db1-ticker.ini install
pgqadm.py /etc/skytools/db1-ticker.ini ticker -d
</PRE>

<P>
Проверим, что в логах (/var/log/skytools/db1-tickers.log) всё нормально. На данном этапе там должны быть редкие записи (раз в минуту).

<P>
Если нам потребуется остановить ticker, мы можем воспользоватся этой командой:
<PRE>
pgqadm.py /etc/skytools/db1-ticker.ini ticker -s
</PRE>
или если потребуется &#171;убить&#187; ticker:
<PRE>
pgqadm.py /etc/skytools/db1-ticker.ini ticker -k
</PRE>

<P>

<H3><A NAME="SECTION00333200000000000000">
Востанавливаем схему базы</A>
</H3>
Londiste не умеет переносить изменения структуры базы данных. 
Поэтому на всех slave базах данных перед репликацией должна быть создана такая же структура БД, что и на мастере.

<P>

<H3><A NAME="SECTION00333300000000000000">
Создаём конфигурацию репликатора</A>
</H3>
Для каждой из реплицируемых баз создадим конфигурационные файлы 
(пусть конфиг будет у нас /etc/skytools/db1-londiste.ini):
<PRE>
[londiste]
# название
job_name = db1-londiste

# мастер база данных
provider_db = dbname=db1 port=5432 host=host1
# слейв база данных
subscriber_db = dbname=db1 host=host2

# Это будет использоваться в качестве 
# SQL-идентификатора, т.ч. не используйте
# точки и пробелы.
# ВАЖНО! Если есть живая репликация на другой слейв, 
# именуем очередь так-же
pgq_queue_name = db1-londiste-queue

# log и pid демона
logfile = /var/log/%(job_name)s.log
pidfile = /var/run/%(job_name)s.pid

# рзмер лога
log_size = 5242880
log_count = 3
</PRE>

<P>

<H3><A NAME="SECTION00333400000000000000">
Устанавливаем Londiste в базы на мастере и слейве</A>
</H3>
Теперь необходимо установить служебный SQL для каждой из созданных в предыдущем
пункте конфигураций.

<P>
Устанавливаем код на стороне мастера:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini provider install
</PRE>
и подобным образом на стороне слейва:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini subscriber install
</PRE>

<P>
После этого пункта на мастере будут созданы очереди для репликации.

<P>

<H3><A NAME="SECTION00333500000000000000">
Запускаем процессы Londiste</A>
</H3>
Для каждой реплицируемой базы делаем:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini replay -d
</PRE>

<P>
Таким образом запустятся слушатели очередей репликации, но, т.к. мы ещё не
указывали какие таблицы хотим реплицировать, они пока будут работать в холостую.

<P>
Убедимся что в логах нет ошибок (/var/log/db1-londistes.log).

<P>

<H3><A NAME="SECTION00333600000000000000">
Добавляем реплицируемые таблицы</A>
</H3>
Для каждой конфигурации указываем что будем реплицировать с мастера:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini provider add --all
</PRE>
и что со слейва:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini subscriber add --all
</PRE>

<P>
В данном примере я использую спец-параметр &#171;-all&#187;, который означает все таблицы,
но вместо него вы можете перечислить список конкретных таблиц, если не хотите
реплицировать все.

<P>

<H3><A NAME="SECTION00333700000000000000">
Добавляем реплицируемые последовательности (sequence)</A>
</H3>
Так же для всех конфигураций.
Для мастера:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini provider add-seq --all
</PRE>
Для слейва:
<PRE>
londiste.py /etc/skytools/db1-londiste.ini subscriber add-seq --all
</PRE>

<P>
Точно также как и с таблицами можно указать конкретные последовательности вместо &#171;-all&#187;.

<P>

<H3><A NAME="SECTION00333800000000000000">
Проверка</A>
</H3>
Итак, всё что надо сделано. Теперь Londiste запустит так называемый bulk copy
процесс, который массово (с помощью COPY) зальёт присутствующие на момент
добавления таблиц данные на слейв, а затем перейдёт в состояние обычной репликации.

<P>
Мониторим логи на предмет ошибок:
<PRE>
less /var/log/db1-londiste.log
</PRE>

<P>
Если всё хорошо, смотрим состояние репликации. Данные уже синхронизированы для
тех таблиц, где статус отображается как "ok".
<PRE>
londiste.py /etc/skytools/db1-londiste.ini subscriber tables

   Table State
   public.table1 ok
   public.table2 ok
   public.table3 in-copy
   public.table4 -
   public.table5 -
   public.table6 -
   ...
</PRE>

<P>
Для удобства представляю следующий трюк с уведомление в почту об окончании
первоначального копирования (мыло поменять на своё):
<PRE>
(
while [ $(
python londiste.py /etc/skytools/db1-londiste.ini subscriber tables |
tail -n+2 | awk '{print $2}' | grep -v ok | wc -l) -ne 0 ];
do sleep 60; done; echo '' | mail -s 'Replication done EOM' user@domain.com
) &amp;
</PRE>

<P>

<H2><A NAME="SECTION00334000000000000000">
Общие задачи</A>
</H2>

<P>

<H3><A NAME="SECTION00334100000000000000">
Добавление всех таблиц мастера слейву</A>
</H3>
Просто используя эту команду:
<PRE>
londiste.py &lt;ini&gt; provider tables | xargs londiste.py &lt;ini&gt; subscriber add
</PRE>

<P>

<H3><A NAME="SECTION00334200000000000000">
Проверка состояния слейвов</A>
</H3>
Этот запрос на мастере дает некоторую информацию о каждой очереди и слейве.
<PRE>
SELECT queue_name, consumer_name, lag, last_seen
  FROM pgq.get_consumer_info();
</PRE>

<P>
&#171;lag&#187; столбец показывает отставание от мастера в синхронизации, 
&#171;last_seen&#187;&nbsp;-- время последней запроса от слейва. Значение этого столбца не должно быть больше, 
чем 60 секунд для конфигурации по умолчанию.

<P>

<H3><A NAME="SECTION00334300000000000000">
Удаление очереди всех событий из мастера</A>
</H3>
При работе с Londiste может потребоватся удалить все ваши настройки для того, чтобы начать все заново. 
Для PGQ, чтобы остановить накопление данных, используйте следующие API:
<PRE>
SELECT pgq.unregister_consumer('queue_name', 'consumer_name');
</PRE>

<P>
Или воспользуйтесь pgqadm.py:
<PRE>
pgqadm.py &lt;ticker.ini&gt; unregister queue_name consumer_name
</PRE>

<P>

<H3><A NAME="SECTION00334400000000000000">
Добавление столбца в таблицу</A>
</H3>
Добавляем в следующей последовательности:

<OL>
<LI>добавить поле на все слейвы
</LI>
<LI>BEGIN; - на мастере
</LI>
<LI>добавить поле на мастере
</LI>
<LI>SELECT londiste.provider_refresh_trigger('queue_name', 'tablename');
</LI>
<LI>COMMIT;
</LI>
</OL>

<P>

<H3><A NAME="SECTION00334500000000000000">
Удаление столбца из таблицу</A>
</H3>

<OL>
<LI>BEGIN; - на мастере
</LI>
<LI>удалить поле на мастере
</LI>
<LI>SELECT londiste.provider_refresh_trigger('queue_name', 'tablename');
</LI>
<LI>COMMIT;
</LI>
<LI>Проверить &#171;lag&#187;, когда londiste пройдет момент удаления поля
</LI>
<LI>удалить поле на всех слейвах
</LI>
</OL>

<P>
Хитрость тут в том, чтобы удалить поле на слейвах только тогда, когда больше нет событий в очереди на это поле.

<P>

<H2><A NAME="SECTION00335000000000000000">
Устранение неисправностей</A>
</H2>

<P>

<H3><A NAME="SECTION00335100000000000000">
Londiste пожирает процессор и lag растет</A>
</H3>
Это происходит, например, если во время сбоя админ забыл перезапустить ticker. Или когда вы сделали большой 
UPDATE или DELETE в одной транзакции, но теперь что бы реализовать каждое собитие в этом запросе создаются 
транзакции на слейвах ...

<P>
Следующий запрос позволяет подсчитать, сколько событий пришло в pgq.subscription в колонках sub_last_tick и sub_next_tick.
<PRE>
SELECT count(*)
  FROM pgq.event_1,
    (SELECT tick_snapshot
      FROM pgq.tick
      WHERE tick_id BETWEEN 5715138 AND 5715139
    ) as t(snapshots)
WHERE txid_visible_in_snapshot(ev_txid, snapshots);
</PRE>

<P>
В нашем случае, это было более чем 5 миллионов и 400 тысяч событий. Многовато. Чем больше событий 
с базы данных требуется обработать Londiste, тем больше ему требуется памяти для этого. Мы можем сообщить 
Londiste не загружать все события сразу. Достаточно добавить в INI конфиг ticker-а следующую настройку:
<PRE>
pgq_lazy_fetch = 500
</PRE>

<P>
Теперь Londiste будет брать максимум 500 событий в один пакет запросов. Остальные попадут в следующие пакеты запросов.

<H1><A NAME="SECTION00340000000000000000">
Bucardo</A>
</H1>

<H2><A NAME="SECTION00341000000000000000">
Введение</A>
</H2>
Bucardo&nbsp;-- асинхронная master-master или master-slave репликация PostgreSQL, которая написана на Perl. 
Система очень гибкая, поддерживает несколько видов синхронизации и обработки конфликтов.

<P>

<H2><A NAME="SECTION00342000000000000000">
Установка</A>
</H2>
Установку будем проводить на Ubuntu Server. Сначала нам нужно установить DBIx::Safe Perl модуль.
<PRE>
sudo aptitude install libdbix-safe-perl
</PRE>

<P>
Для других систем можно поставить из исходников<A NAME="tex2html22"
  HREF="#foot1067"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>:
<PRE>
tar xvfz DBIx-Safe-1.2.5.tar.gz
cd DBIx-Safe-1.2.5
perl Makefile.PL
make &amp;&amp; make test &amp;&amp; sudo make install
</PRE>

<P>
Теперь ставим сам Bucardo. Скачиваем<A NAME="tex2html23"
  HREF="#foot1070"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> его и инсталируем:
<PRE>
tar xvfz Bucardo-4.4.0.tar.gz
cd Bucardo-4.4.0
perl Makefile.PL
make
sudo make install
</PRE>

<P>
Для работы Bucardo потребуется установить поддержку pl/perlu языка PostgreSQL.
<PRE>
sudo aptitude install postgresql-plperl-8.4
</PRE>

<P>
Можем приступать к настройке.

<P>

<H2><A NAME="SECTION00343000000000000000">
Настройка</A>
</H2>

<H3><A NAME="SECTION00343100000000000000">
Инициализация Bucardo</A>
</H3>
Запускаем установку командой:
<PRE>
bucardo_ctl install
</PRE>

<P>
Bucardo покажет настройки подключения к PostgreSQL, которые можно будет изменить:
<PRE>
This will install the bucardo database into an existing Postgres cluster.
Postgres must have been compiled with Perl support,
and you must connect as a superuser

We will create a new superuser named 'bucardo',
and make it the owner of a new database named 'bucardo'

Current connection settings:
1. Host:          &lt;none&gt;
2. Port:          5432
3. User:          postgres
4. Database:      postgres
5. PID directory: /var/run/bucardo
</PRE>

<P>
Когда вы измените требуемые настройки и подтвердите установку, Bucardo создаст пользователя bucardo и базу данных bucardo.
Данный пользователь должен иметь право логинится через Unix socket, поэтому лучше заранее дать ему такие права в pg_hda.conf.

<P>

<H3><A NAME="SECTION00343200000000000000">
Настройка баз данных</A>
</H3>
Теперь нам нужно настроить базы данных, с которыми будет работать Bucardo. 
Пусть у нас будет master_db и slave_db. Сначала настроим мастер:
<PRE>
bucardo_ctl add db master_db name=master
bucardo_ctl add all tables herd=all_tables
bucardo_ctl add all sequences herd=all_tables
</PRE>

<P>
Первой командой мы указали базу данных и дали ей имя master (для того, что в реальной жизни master_db и slave_db 
имеют одинаковое название и их нужно Bucardo отличать). Второй и третей командой мы указали реплицыровать все 
таблицы и последовательности, обьеденив их в групу all_tables.

<P>
Дальше добавляем slave_db:
<PRE>
bucardo_ctl add db slave_db name=replica port=6543 host=slave_host
</PRE>

<P>
Мы назвали replica базу данных в Bucardo.

<P>

<H3><A NAME="SECTION00343300000000000000">
Настройка синхронизации</A>
</H3>
Теперь нам нужно настроить синхронизацию между этими базами данных. Делается это командой (master-slave):
<PRE>
bucardo_ctl add sync delta type=pushdelta source=all_tables targetdb=replica
</PRE>

<P>
Данной командой мы установим Bucardo тригеры в PostgreSQL. А теперь по параметрам:

<UL>
<LI><SPAN  CLASS="textbf">type</SPAN>

<P>
Это тип синхронизации. Существует 3 типа:

<UL>
<LI><SPAN  CLASS="textbf">Fullcopy</SPAN>. Полное копирование.
</LI>
<LI><SPAN  CLASS="textbf">Pushdelta</SPAN>. Master-slave репликация.
</LI>
<LI><SPAN  CLASS="textbf">Swap</SPAN>. Master-master репликация. 
Для работы в таком режиме потребуется указать как Bucardo должен решать конфликты синхронизации.
Для этого в таблице &#171;goat&#187; (в которой находятся таблицы и последовательности) нужно в &#171;standard_conflict&#187; 
поле поставить значение (это значение может быть разным для разных таблиц и последовательностей):

<UL>
<LI>source&nbsp;-- при конфликте мы копируем данные с source (master_db в нашем случае).
</LI>
<LI>target&nbsp;-- при конфликте мы копируем данные с target (slave_db в нашем случае).
</LI>
<LI>skip&nbsp;-- конфликт мы просто не реплицируем. Не рекомендуется.
</LI>
<LI>random&nbsp;-- каждая БД имеет одинаковый шанс, что её изменение будет взято для решение конфликта.
</LI>
<LI>latest&nbsp;-- запись, которая была последней изменена решает конфликт.
</LI>
<LI>abort&nbsp;-- синхронизация прерывается.
</LI>
</UL>
</LI>
</UL>

<P>
</LI>
<LI><SPAN  CLASS="textbf">source</SPAN>

<P>
Источник синхронизации.

<P>
</LI>
<LI><SPAN  CLASS="textbf">targetdb</SPAN>

<P>
БД, в которум производим репликацию.
</LI>
</UL>

<P>
Для master-master:
<PRE>
bucardo_ctl add sync delta type=swap source=all_tables targetdb=replica
</PRE>

<P>

<H3><A NAME="SECTION00343400000000000000">
Запуск репликации</A>
</H3>
Запуск репликации:
<PRE>
bucardo_ctl start
</PRE>

<P>
Остановка репликации:
<PRE>
bucardo_ctl stop
</PRE>

<P>

<H2><A NAME="SECTION00344000000000000000">
Общие задачи</A>
</H2>

<P>

<H3><A NAME="SECTION00344100000000000000">
Просмотр значений конфигурации</A>
</H3>
Просто используя эту команду:
<PRE>
bucardo_ctl show all
</PRE>

<P>

<H3><A NAME="SECTION00344200000000000000">
Изменения значений конфигурации</A>
</H3>
<PRE>
bucardo_ctl set name=value
</PRE>

<P>
Например:
<PRE>
bucardo_ctl set syslog_facility=LOG_LOCAL3
</PRE>

<P>

<H3><A NAME="SECTION00344300000000000000">
Перегрузка конфигурации</A>
</H3>
<PRE>
bucardo_ctl reload_config
</PRE>

<P>
Более полный список команд&nbsp;-- http://bucardo.org/wiki/Bucardo_ctl

<H1><A NAME="SECTION00350000000000000000">
RubyRep</A>
</H1>

<H2><A NAME="SECTION00351000000000000000">
Введение</A>
</H2>
RubyRep представляет собой движок для организации асинхронной репликации, написанный на языке ruby. 
Основные принципы: простота использования и не зависить от БД. 
Поддерживает как master-master, так и master-slave репликацию, может работать с PostgreSQL и MySQL.
Отличительными особенностями решения являются:

<UL>
<LI>возможность двухстороннего сравнения и синхронизации баз данных
</LI>
<LI>простота установки
</LI>
</UL>
К недостаткам можно отнести:

<UL>
<LI>работа только с двумя базами данных для MySQL
</LI>
<LI>медленная работа синхронизации 
</LI>
<LI>при больших обьемах данных &#171;ест&#187; процессор и память
</LI>
</UL>

<P>

<H2><A NAME="SECTION00352000000000000000">
Установка</A>
</H2>
RubyRep поддерживает два типа установки: через стандартный Ruby или JRuby. 
Рекомендую ставить JRuby вариант&nbsp;-- производительность будет выше.

<P>
<SPAN  CLASS="textbf">Установка JRuby версии</SPAN>

<P>
Предварительно должна быть установлена Java (версия 1.6).

<OL>
<LI>Загрузите последнюю версию JRuby rubyrep c Rubyforge<A NAME="tex2html24"
  HREF="#foot1189"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
</LI>
<LI>Распакуйте
</LI>
<LI>Готово
</LI>
</OL>

<P>
<SPAN  CLASS="textbf">Установка стандартной Ruby версии</SPAN>

<OL>
<LI>Установить Ruby, Rubygems.
</LI>
<LI>Установить драйвера базы данных.

<P>
Для Mysql: 
<PRE>
sudo gem install mysql
</PRE>

<P>
Для PostgreSQL:
<PRE>
sudo gem install postgres
</PRE>

<P>
</LI>
<LI>Устанавливаем rubyrep:
<PRE>
sudo gem install rubyrep
</PRE>
</LI>
</OL>

<P>

<H2><A NAME="SECTION00353000000000000000">
Настройка</A>
</H2>

<H3><A NAME="SECTION00353100000000000000">
Создание файла конфигурации</A>
</H3>
Выполним команду:
<PRE>
rubyrep generate myrubyrep.conf
</PRE>

<P>
Команда generate создала пример конфигурации в файл myrubyrep.conf:
<PRE>
RR::Initializer::run do |config|
config.left = {
:adapter  =&gt; 'postgresql', # or 'mysql'
:database =&gt; 'SCOTT',
:username =&gt; 'scott',
:password =&gt; 'tiger',
:host     =&gt; '172.16.1.1'
}
 
config.right = {
:adapter  =&gt; 'postgresql',
:database =&gt; 'SCOTT',
:username =&gt; 'scott',
:password =&gt; 'tiger',
:host     =&gt; '172.16.1.2'
}
 
config.include_tables 'dept'
config.include_tables /^e/ # regexp matches all tables starting with e
# config.include_tables /./ # regexp matches all tables
end
</PRE>

<P>
В настройках просто разобраться. Базы данных делятся на &#171;left&#187; и &#171;right&#187;.
Через config.include_tables мы указываем какие таблицы включать в репликацию (поддерживает RegEx).

<P>

<H3><A NAME="SECTION00353200000000000000">
Сканирование баз данных</A>
</H3>
Сканирование баз данных для поиска различий:
<PRE>
rubyrep scan -c myrubyrep.conf
</PRE>

<P>
Пример вывода:
<PRE>
dept 100% .........................   0
emp 100% .........................   1
</PRE>

<P>
Таблица dept полностью синхронизирована, а emp&nbsp;-- имеет одну не синхронизированую запись.

<P>

<H3><A NAME="SECTION00353300000000000000">
Синхронизация баз данных</A>
</H3>
Выполним команду:
<PRE>
rubyrep sync -c myrubyrep.conf
</PRE>

<P>
Также можно указать только какие таблицы в базах данных синхронизировать:
<PRE>
rubyrep sync -c myrubyrep.conf dept /^e/
</PRE>

<P>
Настройки политики синхронизации позволяют указывать как решать конфликты синхронизации. 
Более подробно можно почитать в документации http://www.rubyrep.org/configuration.html. 

<P>

<H3><A NAME="SECTION00353400000000000000">
Репликация</A>
</H3>
Для запуска репликации достаточно выполнить:
<PRE>
rubyrep replicate -c myrubyrep.conf
</PRE>

<P>
Данная команда установить репликацию (если она не была установлена) на базы данных и запустит её.
Чтобы остановить репликацию, достаточно просто убить процесс. Даже если репликация остановлена, 
все изменения будут обработаны триггерами rubyrep. После перезагрузки, все изменения 
будут автоматически востановлены.

<P>
Для удаления репликации достаточно выполнить:
<PRE>
rubyrep uninstall -c myrubyrep.conf
</PRE>

<P>

<H2><A NAME="SECTION00354000000000000000">
Устранение неисправностей</A>
</H2>

<H3><A NAME="SECTION00354100000000000000">
Ошибка при запуске репликации</A>
</H3>
При зепуске rubyrep через Ruby может возникнуть подобная ошибка:
<PRE>
$rubyrep replicate -c myrubyrep.conf 
Verifying RubyRep tables
Checking for and removing rubyrep triggers from unconfigured tables
Verifying rubyrep triggers of configured tables
Starting replication
Exception caught: Thread#join: deadlock 0xb76ee1ac - mutual join(0xb758cfac)
</PRE>

<P>
Это проблема с запусками потоков в Ruby. Решается двумя способами:

<OL>
<LI>Запускать rubyrep через JRuby (тут с потоками не будет проблем)
</LI>
<LI>Пофиксить rubyrep патчем:
<PRE>
--- /Library/Ruby/Gems/1.8/gems/rubyrep-1.1.2/lib/rubyrep/
replication_runner.rb 2010-07-16 15:17:16.000000000 -0400
+++ ./replication_runner.rb 2010-07-16 17:38:03.000000000 -0400
@@ -2,6 +2,12 @@
 
 require 'optparse'
 require 'thread'
+require 'monitor'
+
+class Monitor
+ alias lock mon_enter
+ alias unlock mon_exit
+end
 
 module RR
   # This class implements the functionality of the 'replicate' command.
@@ -94,7 +100,7 @@
     # Initializes the waiter thread used for replication pauses 
     # and processing
     # the process TERM signal.
     def init_waiter
- @termination_mutex = Mutex.new
+ @termination_mutex = Monitor.new
       @termination_mutex.lock
       @waiter_thread ||= Thread.new {@termination_mutex.lock; 
         self.termination_requested = true}
       %w(TERM INT).each do |signal|
</PRE>
</LI>
</OL>

<H1><A NAME="SECTION00360000000000000000">
Заключение</A>
</H1>
Репликация&nbsp;-- одна из важнейших частей крупных приложений, которые работают на PostgreSQL. Она помогает 
распределять нагрузку на базу данных, делать фоновый бэкап одной из копий без нагрузки на центральный сервер, 
создавать отдельный сервер для логирования и м.д.

<P>
В главе было рассмотрено несколько видов репликации PostgreSQL. Нельзя четко сказать какая лучше всех. 
Slony-I&nbsp;-- громоздкая и сложная в настройке система, 
но имеющая в своем арсенале множество функций, таких как поддержка каскадной репликации, отказоустойчивости(failover) 
и переключение между серверами (switchover). В тоже время Londiste не обладает подобным функционалом, 
но компактный и прост в установке. Bucardo&nbsp;-- система которая может быть или master-master, или 
master-slave репликацией, но не может обработать огромные обьекты, нет отказоустойчивости(failover) 
и переключение между серверами (switchover). RubyRep, как для master-master репликации, 
очень просто в установке и настройке, но за это ему приходится расплачиватся скоростью работы&nbsp;-- самый 
медленный из всех(синхронизация больших обьемов данных между таблицами).

<H1><A NAME="SECTION00400000000000000000">
Кластеризация БД</A>
</H1>

<H1><A NAME="SECTION00410000000000000000">
Введение</A>
</H1>
Кластер (в информацонных технологиях)&nbsp;-- группа серверов (программных или аппаратных), объединённых логически, 
способных обрабатывать идентичные запросы и использующихся как единый ресурс. Для PostgreSQL это означает, что несколько серверов 
баз данных ведут себя как одна база данных. В большинстве случаев, кластеры серверов функционируют на раздельных компьютерах. 
Это позволяет повышать производительность за счёт распределения нагрузки на аппаратные ресурсы и обеспечивает отказоустойчивость 
на аппаратном уровне.

<P>
Для создания кластера PostgreSQL существует несколько решений:

<UL>
<LI><SPAN  CLASS="textbf">Greenplum Database</SPAN><A NAME="tex2html25"
  HREF="#foot1280"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>
</LI>
<LI><SPAN  CLASS="textbf">GridSQL for EnterpriseDB Advanced Server</SPAN><A NAME="tex2html26"
  HREF="#foot1282"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>
</LI>
<LI><SPAN  CLASS="textbf">PL/Proxy</SPAN><A NAME="tex2html27"
  HREF="#foot1284"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>
</LI>
<LI><SPAN  CLASS="textbf">HadoopDB</SPAN><A NAME="tex2html28"
  HREF="#foot1286"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>
</LI>
</UL>

<H1><A NAME="SECTION00420000000000000000">
PL/Proxy</A>
</H1>
PL/Proxy представляет собой прокси-язык для удаленного вызова процедур и партицирования данных между разными базами. 
Основная идея его использования заключается в том, что появляется возможность вызывать функции, расположенные в удаленных 
базах, а также свободно работать с кластером баз данных (например, вызвать функцию на всех узлах кластера, или на 
случайном узле, или на каком-то одном определенном).

<P>
Чем PL/Proxy может быть полезен? Он существенно упрощает горизонтальное масштабирование системы. 
Становится удобным разделять таблицу с пользователями, например, по первой латинской букве имени&nbsp;-- на 26 узлов. 
При этом приложение, которое работает непосредственно с прокси-базой, ничего не будет замечать: запрос на авторизацию, 
например, сам будет направлен прокси-сервером на нужный узел. То есть администратор баз данных может проводить масштабирование 
системы практически независимо от разработчиков приложения.

<P>
PL/Proxy позволяет полностью решить проблемы масштабирования OLTP систем. В систему легко вводится резервирование с 
failover-ом не только по узлам, но и по самим прокси-серверам, каждый из которых работает со всеми узлами.

<P>
Недостатки и ограничения:

<UL>
<LI>все запросы и вызовы функций вызываются в autocommit-режиме на удаленных серверах
</LI>
<LI>в теле функции разрешен только один SELECT; при необходимости нужно писать отдельную процедуру
</LI>
<LI>при каждом вызове прокси-сервер стартует новое соединение к бакенд-серверу; в высоконагруженных системах 
целесообразно использовать менеджер для кеширования соединений к бакенд-серверам, для этой цели идеально подходит PgBouncer
</LI>
<LI>изменение конфигурации кластера (количества партиций, например) требует перезапуска прокси-сервера
</LI>
</UL>

<P>

<H2><A NAME="SECTION00421000000000000000">
Установка</A>
</H2>

<OL>
<LI>Скачать PL/Proxy<A NAME="tex2html29"
  HREF="#foot1303"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> и распаковать.
</LI>
<LI>Собрать PL/Proxy командами make и make install. 
</LI>
</OL>

<P>
Так же можно установить PL/Proxy из репозитория пакетов. 
Например в Ubuntu Server достаточно выполнить команду для PostgreSQL 8.4:
<PRE>
sudo aptitude install postgresql-8.4-plproxy
</PRE>

<P>

<H2><A NAME="SECTION00422000000000000000">
Настройка</A>
</H2>
Для примера настройки используется 3 сервера PostgreSQL. 2 сервера пусть будут node1 и node2, 
а главный, что будет проксировать запросы на два других&nbsp;-- proxy.
Для корректной работы pl/proxy рекомендуется использовать количество нод равное степеням двойки. 
База данных будет называтся plproxytest, а таблица в ней&nbsp;-- users. Начнем!

<P>
Для начала настроим node1 и node2. Команды написаные нижу нужно выполнять на каждом ноде.

<P>
Создадим базу данных plproxytest(если её ещё нет):
<PRE>
CREATE DATABASE plproxytest
     WITH OWNER = postgres
       ENCODING = 'UTF8';
</PRE>

<P>
Добавляем табличку users:
<PRE>
CREATE TABLE public.users
  (
   username character varying(255),
   email character varying(255)
  )
  WITH (OIDS=FALSE);
ALTER TABLE public.users OWNER TO postgres;
</PRE>

<P>
Теперь создадим функцию для добавления данных в таблицу users:
<PRE>
CREATE OR REPLACE FUNCTION public.insert_user(i_username text, 
i_emailaddress   text)
RETURNS integer AS
$BODY$
INSERT INTO public.users (username, email) VALUES ($1,$2);
    SELECT 1;
$BODY$
  LANGUAGE 'sql' VOLATILE;
ALTER FUNCTION public.insert_user(text, text) OWNER TO postgres;
</PRE>

<P>
С настройкой нодов закончено. Приступим к серверу proxy.

<P>
Как и на всех нодах, на главном сервере (proxy) должна присутствовать база данных: 
<PRE>
CREATE DATABASE plproxytest
     WITH OWNER = postgres
       ENCODING = 'UTF8';
</PRE>

<P>
Теперь надо укзать серверу что эта база данных управляется с помощью pl/proxy:
<PRE>
CREATE OR REPLACE FUNCTION public.plproxy_call_handler()
  RETURNS language_handler AS
'$libdir/plproxy', 'plproxy_call_handler'
  LANGUAGE 'c' VOLATILE
COST 1;
ALTER FUNCTION public.plproxy_call_handler() 
OWNER TO postgres;
-- language
CREATE LANGUAGE plproxy HANDLER plproxy_call_handler;
CREATE LANGUAGE plpgsql;
</PRE>

<P>
Также, для того что бы сервер знал где и какие ноды него есть надо создать 
3 сервисные функции которые pl/proxy будет использовать в своей работе. 
Первая функция&nbsp;-- конфиг для кластера баз данных. Тут указывается параметры через kay-value:
<PRE>
CREATE OR REPLACE FUNCTION public.get_cluster_config
(IN cluster_name text,   OUT "key" text, OUT val text)
  RETURNS SETOF record AS
$BODY$
BEGIN
  -- lets use same config for all clusters
  key := 'connection_lifetime';
  val := 30*60; -- 30m
  RETURN NEXT;
  RETURN;
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION public.get_cluster_config(text) 
OWNER TO postgres;
</PRE>

<P>
Вторая важная функция код которой надо будет подправить. В ней надо будет указать DSN нод:
<PRE>
СREATE OR REPLACE FUNCTION 
public.get_cluster_partitions(cluster_name text)
  RETURNS SETOF text AS
$BODY$
BEGIN
  IF cluster_name = 'usercluster' THEN
    RETURN NEXT 'dbname=plproxytest host=node1 user=postgres';
    RETURN NEXT 'dbname=plproxytest host=node2 user=postgres';
    RETURN;
  END IF;
  RAISE EXCEPTION 'Unknown cluster';
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100
  ROWS 1000;
ALTER FUNCTION public.get_cluster_partitions(text) 
OWNER TO postgres;
</PRE>

<P>
И последняя:
<PRE>
CREATE OR REPLACE FUNCTION 
public.get_cluster_version(cluster_name text)
  RETURNS integer AS
$BODY$
BEGIN
  IF cluster_name = 'usercluster' THEN
    RETURN 1;
  END IF;
  RAISE EXCEPTION 'Unknown cluster';
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;
ALTER FUNCTION public.get_cluster_version(text) 
OWNER TO postgres;
</PRE>

<P>
Ну и собственно самая главная функция которая будет вызываться уже непосредственно в приложении:
<PRE>
CREATE OR REPLACE FUNCTION 
public.insert_user(i_username text, i_emailaddress text)
  RETURNS integer AS
$BODY$
  CLUSTER 'usercluster';
  RUN ON hashtext(i_username);
$BODY$
  LANGUAGE 'plproxy' VOLATILE
  COST 100;
ALTER FUNCTION public.insert_user(text, text) 
OWNER TO postgres;
</PRE>

<P>
Все готово. Подключаемся к серверу proxy и заносим данные в базу:
<PRE>
SELECT insert_user('Sven','sven@somewhere.com');
SELECT insert_user('Marko', 'marko@somewhere.com');
SELECT insert_user('Steve','steve@somewhere.com');
</PRE>

<P>
Пробуем извлечь данные.
Для этого напишем новую серверную функцию: 
<PRE>
CREATE OR REPLACE FUNCTION 
public.get_user_email(i_username text)
 RETURNS SETOF text AS
$BODY$
 CLUSTER 'usercluster';
 RUN ON hashtext(i_username) ;
 SELECT email FROM public.users 
 WHERE username = i_username;
$BODY$
 LANGUAGE 'plproxy' VOLATILE
 COST 100
 ROWS 1000;
ALTER FUNCTION public.get_user_email(text) 
OWNER TO postgres;
</PRE>

<P>
И попробуем её вызвать:
<PRE>
select plproxy.get_user_email('Steve');
</PRE>

<P>
Если потом подключится к каждой ноде отдельно, то можно четко увидеть, что данные users разбросаны по таблицам каждой ноды.

<P>

<H2><A NAME="SECTION00423000000000000000">
Все ли так просто?</A>
</H2>
Как видно на тестовом примере ничего сложного в работе с pl/proxy нет. 
Но, я думаю все кто смог дочитать до этой строчки уже поняли что в реальной жизни все не так просто.
Представьте что у вас 16 нод. Это же надо как-то синхронизировать код функций. А что если ошибка закрадётся&nbsp;-- 
как её оперативно исправлять?

<P>
Этот вопрос был задан и на конференции Highload++ 2008, на что Аско Ойя ответил что соответствующие средства 
уже реализованы внутри самого Skype, но ещё не достаточно готовы для того что бы отдавать их на суд сообществе opensource.

<P>
Второй проблема которая не дай бог коснётся вас при разработке такого рода системы, это проблема перераспределения данных 
в тот момент когда нам захочется добавить ещё нод в кластер.
Планировать эту масштабную операцию прийдётся очень тщательно, подготовив все сервера заранее, 
занеся данные и потом в один момент подменив код функции get_cluster_partitions.

<H1><A NAME="SECTION00430000000000000000">
HadoopDB</A>
</H1>
Hadoop  представляет собой платформу для построения приложений, способных обрабатывать огромные объемы данных. 
Система основывается на распределенном подходе к вычислениям и хранению информации, основными ее особенностями являются:

<UL>
<LI><SPAN  CLASS="textbf">Масштабируемость:</SPAN> с помощью Hadoop возможно надежное хранение и обработка огромных объемов данных, 
которые могут измеряться петабайтами;
</LI>
<LI><SPAN  CLASS="textbf">Экономичность:</SPAN> информация и вычисления распределяются по кластеру, построенному на самом 
обыкновенном оборудовании. Такой кластер может состоять из тысяч узлов;
</LI>
<LI><SPAN  CLASS="textbf">Эффективность:</SPAN> распределение данных позволяет выполнять их обработку параллельно на множестве компьютеров, 
что существенно ускоряет этот процесс;
</LI>
<LI><SPAN  CLASS="textbf">Надежность:</SPAN> при хранении данных возможно предоставление избыточности, благодаря хранению нескольких копий. 
Такой подход позволяет гарантировать отсутствие потерь информации в случае сбоев в работе системы;
</LI>
<LI><SPAN  CLASS="textbf">Кроссплатформенность:</SPAN> так как основным языком программирования, используемым в этой системе является Java, 
развернуть ее можно на базе любой операционной системы, имеющей JVM.
</LI>
</UL>

<P>
<SPAN  CLASS="textbf">HDFS</SPAN>

<P>
В основе всей системы лежит распределенная файловая система под незамысловатым названием Hadoop 
Distributed File System. Представляет она собой вполне стандартную распределенную файловую систему, но все же 
она обладает рядом особенностей:

<UL>
<LI>Устойчивость к сбоям, разработчики рассматривали сбои в оборудовании скорее как норму, чем как исключение;
</LI>
<LI>Приспособленность к развертке на самом обыкновенном ненадежном оборудовании;
</LI>
<LI>Предоставление высокоскоростного потокового доступа ко всем данным;
</LI>
<LI>Настроена для работы с большими файлами и наборами файлов;
</LI>
<LI>Простая модель работы с данными: один раз записали&nbsp;-- много раз прочли;
</LI>
<LI>Следование принципу: переместить вычисления проще, чем переместить данные;
</LI>
</UL>

<P>
<SPAN  CLASS="textbf">Архитектура HDFS</SPAN>

<P>

<DIV ALIGN="CENTER"><A NAME="ris:hdfsarchitecture"></A><A NAME="1397"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
Архитектура HDFS</CAPTION>
<TR><TD>[width=1]hdfsarchitecture</TD></TR>
</TABLE>
</DIV>

<P>

<UL>
<LI><SPAN  CLASS="textbf">Namenode</SPAN>

<P>
Этот компонент системы осуществляет всю работу с метаданными. Он должен быть запущен только на одном компьютере 
в кластере. Именно он управляет размещением информации и доступом ко всем данным, расположенным на ресурсах кластера. 
Сами данные проходят с остальных машин кластера к клиенту мимо него.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Datanode</SPAN>

<P>
На всех остальных компьютерах системы работает именно этот компонент. Он располагает сами блоки данных в локальной 
файловой системе для последующей передачи или обработки их по запросу клиента. Группы узлов данных принято называть 
Rack, они используются, например, в схемах репликации данных.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Клиент</SPAN>

<P>
Просто приложение или пользователь, работающий с файловой системой. В его роли может выступать практически что угодно.
</LI>
</UL>

<P>
Пространство имен HDFS имеет классическую иерархическую структуру: пользователи и приложения имеют возможность 
создавать директории и файлы. Файлы хранятся в виде блоков данных произвольной (но одинаковой, за исключением последнего; 
по-умолчанию 64 mb) длины, размещенных на Datanode'ах. Для обеспечения отказоустойчивости блоки хранятся в нескольких 
экземплярах на разных узлах, имеется возможность настройки количества копий и алгоритма их распределения по системе. 
Удаление файлов происходит не сразу, а через какое-то время после соответствующего запроса, так как после получения 
запроса файл перемещается в директорию /trash и хранится там определенный период времени на случай если пользователь 
или приложение передумают о своем решении. В этом случае информацию можно будет восстановить, в противном случае&nbsp;-- физически удалить.

<P>
Для обнаружения возникновения каких-либо неисправностей, Datanode периодически отправляют Namenode'у сигналы о 
своей работоспособности. При прекращении получения таких сигналов от одного из узлов Namenode помечает его как &#171;мертвый&#187;, 
и прекращает какой-либо с ним взаимодействие до возвращения его работоспособности. Данные, хранившиеся на &#171;умершем&#187; узле 
реплицируются дополнительный раз из оставшихся «в живых» копий и система продолжает свое функционирование как ни в чем не бывало.

<P>
Все коммуникации между компонентами файловой системы проходят по специальным протоколам, основывающимся на стандартном TCP/IP. 
Клиенты работают с Namenode с помощью так называемого ClientProtocol, а передача данных происходит по DatanodeProtocol, 
оба они обернуты в Remote Procedure Call (RPC).

<P>
Система предоставляет несколько интерфейсов, среди которых командная оболочка DFSShell, набор ПО для администрирования DFSAdmin, 
а также простой, но эффективный веб-интерфейс. Помимо этого существуют несколько API для языков программирования: Java API, 
C pipeline, WebDAV и так далее.

<P>
<SPAN  CLASS="textbf">MapReduce</SPAN>

<P>
Помимо файловой системы, Hadoop включает в себя framework для проведения масштабных вычислений, обрабатывающих 
огромные объемы данных. Каждое такое вычисление называется Job (задание) и состоит оно, как видно из названия, из двух этапов:

<P>

<UL>
<LI><SPAN  CLASS="textbf">Map</SPAN>

<P>
Целью этого этапа является представление произвольных данных (на практике чаще всего просто пары ключ-значение) в виде 
промежуточных пар ключ-значение. Результаты сортируются и групируются по ключу и передаются на следующий этап.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Reduce</SPAN>

<P>
Полученные после map значения используются для финального вычисления требуемых данных. Практические любые данные могут 
быть получены таким образом, все зависит от требований и функционала приложения.
</LI>
</UL>

<P>
Задания выполняются, подобно файловой системе, на всех машинах в кластере (чаще всего одних и тех же). Одна из них выполняет 
роль управления работой остальных — JobTracker, остальные же ее бесприкословно слушаются — TaskTracker. В задачи 
JobTracker'а входит составление расписания выполняемых работ, наблюдение за ходом выполнения, и перераспределение в случае 
возникновения сбоев.

<P>
В общем случае каждое приложение, работающее с этим framework'ом, предоставляет методы для осуществления этапов map и reduce, 
а также указывает расположения входных и выходных данных. После получения этих данных JobTracker распределяет задание между 
остальными машинами и предоставляет клиенту полную информацию о ходе работ.

<P>
Помимо основных вычислений могут выполняться вспомогательные процессы, такие как составление отчетов о ходе работы, кэширование, 
сортировка и так далее.

<P>
<SPAN  CLASS="textbf">HBase</SPAN>

<P>
В рамках Hadoop доступна еще и система хранения данных, которую правда сложно назвать СУБД в традиционном смысле этого слова. 
Чаще проводят аналогии с проприетарной системой этого же плана от Google&nbsp;-- BigTable.

<P>
HBase представляет собой распределенную систему хранения больших объемов данных. Подобно реляционным СУБД данные хранятся в 
виде таблиц, состоящих из строк и столбцов. И даже для доступа к ним предоставляется язык запросов HQL (как ни странно&nbsp;-- 
Hadoop Query Language), отдаленно напоминающий более распространенный SQL. Помимо этого предоставляется итерирующмй интерфейс 
для сканирования наборов строк.

<P>
Одной из основных особенностей хранения данных в HBase является возможность наличия нескольких значений, 
соответствующих одной комбинации таблица-строка-столбец, для их различения используется информация о времени добавления записи. 
На концептуальном уровне таблицы обычно представляют как набор строк, но физически же они хранятся по столбцам, достаточно 
важный факт, который стоит учитывать при разработки схемы хранения данных. Пустые ячейки не отображаются каким-либо образом 
физически в хранимых данных, они просто отсутствуют. Существуют конечно и другие нюансы, но я постарался упомянуть лишь основные.

<P>
HQL очень прост по своей сути, если Вы уже знаете SQL, то для изучения его Вам понадобится лишь просмотреть по диагонали 
коротенький вывод команды help;, занимающий всего пару экранов в консоли. Все те же SELECT, INSERT, UPDATE, DROP и так далее, 
лишь со слегка измененным синтаксисом.

<P>
Помимо обычно командной оболочки HBase Shell, для работы с HBase также предоставлено несколько API для различных языков 
программирования: Java, Jython, REST и Thrift.

<P>
<SPAN  CLASS="textbf">HadoopDB</SPAN>

<P>
В проекте HadoopDB специалисты из университетов Yale и Brown предпринимают попытку создать гибридную систему управления 
данными, сочетающую преимущества технологий и MapReduce, и параллельных СУБД. В их подходе MapReduce обеспечивает коммуникационную 
инфраструктуру, объединяющую произвольное число узлов, в которых выполняются экземпляры традиционной СУБД. Запросы формулируются 
на языке SQL, транслируются в среду MapReduce, и значительная часть работы передается в экземпляры СУБД. Наличие MapReduce 
обеспечивается масштабируемость и отказоустойчивость, а использование в узлах кластера СУБД позволяет добиться высокой 
производительности. 

<P>

<H2><A NAME="SECTION00431000000000000000">
Установка и настройка</A>
</H2>
Вся настройка ведется на Ubuntu Server операционной системе.

<P>

<H3><A NAME="SECTION00431100000000000000">
Установка Hadoop</A>
</H3>
Перед тем, как приступить собственно говоря к установке Hadoop, необходимо выполнить два элементарных действия, 
необходимых для правильного функционирования системы:

<UL>
<LI>открыть доступ одному из пользователей по ssh к этому же компьютеру без пароля, 
можно например создать отдельного пользователя для этого [hadoop]:
<PRE>
sudo groupadd hadoop
sudo useradd -m -g hadoop -d /home/hadoop -s /bin/bash \
-c "Hadoop software owner" hadoop
</PRE>

<P>
Далее действия выполняем от его имени:
<PRE>
su hadoop
</PRE>

<P>
Генерируем RSA-ключ для обеспечения аутентификации в условиях отсутствия возможности использовать пароль:
<PRE>
hadoop@localhost ~ $ ssh-keygen -t rsa -P ""
Generating public/private rsa key pair.
Enter file in which to save the key (/home/hadoop/.ssh/id_rsa):
Your identification has been saved in /home/hadoop/.ssh/id_rsa.
Your public key has been saved in /home/hadoop/.ssh/id_rsa.pub.
The key fingerprint is:
7b:5c:cf:79:6b:93:d6:d6:8d:41:e3:a6:9d:04:f9:85 hadoop@localhost
</PRE>

<P>
И добавляем его в список авторизованных ключей:
<PRE>
cat $HOME/.ssh/id_rsa.pub &gt;&gt; $HOME/.ssh/authorized_keys
</PRE>

<P>
Этого должно быть более чем достаточно, проверить работоспособность соединения можно просто написав:
<PRE>
ssh localhost
</PRE>

<P>
Не забываем предварительно инициализировать sshd:
<PRE>
/etc/init.d/sshd start
</PRE>

<P>
</LI>
<LI>Помимо этого необходимо убедиться в наличии установленной JVM версии 1.5.0 или выше.
<PRE>
sudo aptitude install openjdk-6-jdk
</PRE>
</LI>
</UL>

<P>
Дальше скачиваем и устанавливаем Hadoop:
<PRE>
cd /opt
sudo wget http://www.gtlib.gatech.edu/pub/apache/hadoop
/core/hadoop-0.20.2/hadoop-0.20.2.tar.gz
sudo tar zxvf hadoop-0.20.2.tar.gz
sudo ln -s /opt/hadoop-0.20.2 /opt/hadoop
sudo chown -R hadoop:hadoop /opt/hadoop /opt/hadoop-0.20.2
sudo mkdir -p /opt/hadoop-data/tmp-base
sudo chown -R hadoop:hadoop /opt/hadoop-data/
</PRE>

<P>
Далее переходим в /opt/hadoop/conf/hadoop-env.sh и добавляем вначале:
<PRE>
export JAVA_HOME=/usr/lib/jvm/java-6-openjdk
export HADOOP_HOME=/opt/hadoop
export HADOOP_CONF=$HADOOP_HOME/conf
export HADOOP_PATH=$HADOOP_HOME/bin
export HIVE_HOME=/opt/hive
export HIVE_PATH=$HIVE_HOME/bin

export PATH=$HIVE_PATH:$HADOOP_PATH:$PATH
</PRE>

<P>
Далее добавим в /opt/hadoop/conf/hadoop-site.xml:
<PRE>
&lt;configuration&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
  &lt;value&gt;/opt/hadoop-data/tmp-base&lt;/value&gt;
  &lt;description&gt;A base for other temporary 
  directories&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;fs.default.name&lt;/name&gt;
  &lt;value&gt;localhost:54311&lt;/value&gt;
  &lt;description&gt;
    The name of the default file system.
  &lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoopdb.config.file&lt;/name&gt;
  &lt;value&gt;HadoopDB.xml&lt;/value&gt;
  &lt;description&gt;The name of the HadoopDB 
  cluster configuration file&lt;/description&gt;
&lt;/property&gt;
&lt;/configuration&gt;
</PRE>

<P>
В /opt/hadoop/conf/mapred-site.xml:
<PRE>
&lt;configuration&gt;
&lt;property&gt;
  &lt;name&gt;mapred.job.tracker&lt;/name&gt;
  &lt;value&gt;localhost:54310&lt;/value&gt;
  &lt;description&gt;
    The host and port that the 
    MapReduce job tracker runs at.
  &lt;/description&gt;
&lt;/property&gt;
&lt;/configuration&gt;
</PRE>

<P>
В /opt/hadoop/conf/hdfs-site.xml:
<PRE>
&lt;configuration&gt;
&lt;property&gt;
  &lt;name&gt;dfs.replication&lt;/name&gt;
  &lt;value&gt;1&lt;/value&gt;
  &lt;description&gt;
    Default block replication.
  &lt;/description&gt;
&lt;/property&gt;
&lt;/configuration&gt;
</PRE>

<P>
Теперь необходимо отформатировать Namenode:
<PRE>
$ hadoop namenode -format
10/05/07 14:24:12 INFO namenode.NameNode: STARTUP_MSG: 
/************************************************************
STARTUP_MSG: Starting NameNode
STARTUP_MSG:   host = hadoop1/127.0.1.1
STARTUP_MSG:   args = [-format]
STARTUP_MSG:   version = 0.20.2
STARTUP_MSG:   build = https://svn.apache.org/repos
/asf/hadoop/common/branches/branch-0.20 -r
911707; compiled by 'chrisdo' on Fri Feb 19 08:07:34 UTC 2010
************************************************************/
10/05/07 14:24:12 INFO namenode.FSNamesystem: 
fsOwner=hadoop,hadoop
10/05/07 14:24:12 INFO namenode.FSNamesystem: 
supergroup=supergroup
10/05/07 14:24:12 INFO namenode.FSNamesystem: 
isPermissionEnabled=true
10/05/07 14:24:12 INFO common.Storage: 
Image file of size 96 saved in 0 seconds.
10/05/07 14:24:12 INFO common.Storage: 
Storage directory /opt/hadoop-data/tmp-base/dfs/name has been
successfully formatted.
10/05/07 14:24:12 INFO namenode.NameNode: 
SHUTDOWN_MSG: 
/************************************************************
SHUTDOWN_MSG: Shutting down NameNode at hadoop1/127.0.1.1
************************************************************/
$
</PRE>

<P>
Готово. Теперь мы можем запустить Hadoop:
<PRE>
$ start-all.sh
starting namenode, logging to /opt/hadoop/bin/..
/logs/hadoop-hadoop-namenode-hadoop1.out
localhost: starting datanode, logging to 
/opt/hadoop/bin/../logs/hadoop-hadoop-datanode-hadoop1.out
localhost: starting secondarynamenode, logging to
/opt/hadoop/bin/../logs/hadoop-hadoop-secondarynamenode-hadoop1.out
starting jobtracker, logging to 
/opt/hadoop/bin/../logs/hadoop-hadoop-jobtracker-hadoop1.out
localhost: starting tasktracker, logging to
/opt/hadoop/bin/../logs/hadoop-hadoop-tasktracker-hadoop1.out
$
</PRE>

<P>
Остановка Hadoop производится скриптом stop-all.sh.

<P>

<H3><A NAME="SECTION00431200000000000000">
Установка HadoopDB и Hive</A>
</H3>
Теперь скачаем HaddopDB<A NAME="tex2html31"
  HREF="#foot1445"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> и распакуем hadoopdb.jar в $HADOOP_HOME/lib:
<PRE>
$cp hadoopdb.jar $HADOOP_HOME/lib
</PRE>

<P>
Также нам потребуется PostgreSQL JDBC библиотека. Скачайте её<A NAME="tex2html32"
  HREF="#foot1448"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> и 
распакуйте в директорию $HADOOP_HOME/lib.

<P>
Hive используется HadoopDB как SQL интерфейс. Подготовим директорию в HDFS для Hive:
<PRE>
hadoop fs -mkdir /tmp
hadoop fs -mkdir /user/hive/warehouse
hadoop fs -chmod g+w /tmp
hadoop fs -chmod g+w /user/hive/warehouse
</PRE>

<P>
В архиве HadoopDB также есть архив SMS_dist. Распакуем его:
<PRE>
tar zxvf SMS_dist.tar.gz
sudo mv dist /opt/hive
sudo chown -R hadoop:hadoop hive
</PRE>

<P>
Поскольку мы успешно запустили Hadoop, то и проблем с запуском Hive не должно быть:
<PRE>
$ hive
Hive history file=/tmp/hadoop/
hive_job_log_hadoop_201005081717_1990651345.txt
hive&gt; 

hive&gt; quit;
$
</PRE>

<P>

<H3><A NAME="SECTION00431300000000000000">
Тестирование</A>
</H3>
Теперь проведем тестирование. Скачаем бенчмарк:
<PRE>
svn co http://graffiti.cs.brown.edu/svn/benchmarks/
cd benchmarks/datagen/teragen
</PRE>

<P>
Изменим скрипт benchmarks/datagen/teragen/teragen.pl:
<PRE>
use strict;
use warnings;

my $CUR_HOSTNAME = `hostname -s`;
chomp($CUR_HOSTNAME);

my $NUM_OF_RECORDS_1TB    = 10000000000;
my $NUM_OF_RECORDS_535MB  = 100;
my $BASE_OUTPUT_DIR   = "/data";
my $PATTERN_STRING    = "XYZ";
my $PATTERN_FREQUENCY = 108299;
my $TERAGEN_JAR       = "teragen.jar";
my $HADOOP_COMMAND    = $ENV{'HADOOP_HOME'}."/bin/hadoop";

my %files = ( "535MB" =&gt; 1,
);
system("$HADOOP_COMMAND fs -rmr $BASE_OUTPUT_DIR");
foreach my $target (keys %files) {
my $output_dir = $BASE_OUTPUT_DIR."/SortGrep$target";
my $num_of_maps = $files{$target};
my $num_of_records = ($target eq "535MB" ? 
$NUM_OF_RECORDS_535MB : $NUM_OF_RECORDS_1TB);
print "Generating $num_of_maps files in '$output_dir'\n";

##
## EXEC: hadoop jar teragen.jar 10000000000 
## /data/SortGrep/ XYZ 108299 100
##
my @args = ( $num_of_records,
	    $output_dir,
	    $PATTERN_STRING,
	    $PATTERN_FREQUENCY,
	    $num_of_maps );
my $cmd = "$HADOOP_COMMAND jar $TERAGEN_JAR ".join(" ", @args);
print "$cmd\n";
system($cmd) == 0 || die("ERROR: $!");
} # FOR
exit(0);
</PRE>

<P>
При запуске данного Perl скрипта сгенерится данные, которые будут сохранены на HDFS. 
Поскольку мы настроили систему как единственный кластер, то все данные будут загружены на один HDFS. 
При работе с большим количеством кластеров данные были бы распределены по кластерам.
Создадим базу данных, таблицу и загрузим данные, что мы сохранили на HDFS, в нее:
<PRE>
$hadoop fs -get /data/SortGrep535MB/part-00000 my_file
$psql
psql&gt; CREATE DATABASE grep0;
psql&gt; USE grep0;
psql&gt; CREATE TABLE grep (
    -&gt;   key1 character varying(255),
    -&gt;   field character varying(255)
    -&gt; );
COPY grep FROM 'my_file' WITH DELIMITER '|';
</PRE>

<P>
Теперь настроим HadoopDB. В архиве HadoopDB можно найти пример файла Catalog.properties. Распакуйт его и настройте:
<PRE>
#Properties for Catalog Generation
##################################
nodes_file=machines.txt
relations_unchunked=grep, EntireRankings
relations_chunked=Rankings, UserVisits
catalog_file=HadoopDB.xml
##
#DB Connection Parameters
##
port=5432
username=postgres
password=password
driver=com.postgresql.Driver
url_prefix=jdbc\:postgresql\://
##
#Chunking properties
##
chunks_per_node=0
unchunked_db_prefix=grep
chunked_db_prefix=cdb
##
#Replication Properties
##
dump_script_prefix=/root/dump_
replication_script_prefix=/root/load_replica_
dump_file_u_prefix=/mnt/dump_udb
dump_file_c_prefix=/mnt/dump_cdb
##
#Cluster Connection
##
ssh_key=id_rsa
</PRE>

<P>
Создайте файл machines.txt и добавте туда &#171;localhost&#187; строчку (без кавычек). Тепер создадим HadoopDB конфиг и скопируем его в HDFS:
<PRE>
java -cp $HADOOP_HOME/lib/hadoopdb.jar \
&gt; edu.yale.cs.hadoopdb.catalog.SimpleCatalogGenerator \
&gt; Catalog.properties
hadoop dfs -put HadoopDB.xml HadoopDB.xml
</PRE>

<P>
Теперь мы готовы проверить работы HadoopDB. Теперь можем протестировать поиск по данным, загруженым ранее в БД и HDFS:
<PRE>
java -cp $CLASSPATH:hadoopdb.jar \
&gt; edu.yale.cs.hadoopdb.benchmark.GrepTaskDB \
&gt; -pattern %wo% -output padraig -hadoop.config.file HadoopDB.xml
</PRE>

<P>
Приблизительный результат:
<PRE>
$java -cp $CLASSPATH:hadoopdb.jar edu.yale.cs.hadoopdb.benchmark.GrepTaskDB \
&gt; -pattern %wo% -output padraig -hadoop.config.file HadoopDB.xml
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.exec.DBJobBase initConf
INFO: SELECT key1, field FROM grep WHERE field LIKE '%%wo%%';
14.08.2010 19:08:48 org.apache.hadoop.metrics.jvm.JvmMetrics init
INFO: Initializing JVM Metrics with processName=JobTracker, sessionId=
14.08.2010 19:08:48 org.apache.hadoop.mapred.JobClient configureCommandLineOptions
WARNING: Use GenericOptionsParser for parsing the arguments. 
Applications should implement Tool for the same.
14.08.2010 19:08:48 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO: Running job: job_local_0001
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader getConnection
INFO: Data locality failed for leo-pgsql
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader getConnection
INFO: Task from leo-pgsql is connecting to chunk 0 on host localhost with 
db url jdbc:postgresql://localhost:5434/grep0
14.08.2010 19:08:48 org.apache.hadoop.mapred.MapTask runOldMapper
INFO: numReduceTasks: 0
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader close
INFO: DB times (ms): connection = 104, query execution = 20, row retrieval  = 79
14.08.2010 19:08:48 edu.yale.cs.hadoopdb.connector.AbstractDBRecordReader close
INFO: Rows retrieved = 3
14.08.2010 19:08:48 org.apache.hadoop.mapred.Task done
INFO: Task:attempt_local_0001_m_000000_0 is done. And is in the process of commiting
14.08.2010 19:08:48 org.apache.hadoop.mapred.LocalJobRunner$Job statusUpdate
INFO: 
14.08.2010 19:08:48 org.apache.hadoop.mapred.Task commit
INFO: Task attempt_local_0001_m_000000_0 is allowed to commit now
14.08.2010 19:08:48 org.apache.hadoop.mapred.FileOutputCommitter commitTask
INFO: Saved output of task 'attempt_local_0001_m_000000_0' to file:/home/leo/padraig
14.08.2010 19:08:48 org.apache.hadoop.mapred.LocalJobRunner$Job statusUpdate
INFO: 
14.08.2010 19:08:48 org.apache.hadoop.mapred.Task sendDone
INFO: Task 'attempt_local_0001_m_000000_0' done.
14.08.2010 19:08:49 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO:  map 100% reduce 0%
14.08.2010 19:08:49 org.apache.hadoop.mapred.JobClient monitorAndPrintJob
INFO: Job complete: job_local_0001
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO: Counters: 6
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:   FileSystemCounters
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     FILE_BYTES_READ=141370
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     FILE_BYTES_WRITTEN=153336
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:   Map-Reduce Framework
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Map input records=3
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Spilled Records=0
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Map input bytes=3
14.08.2010 19:08:49 org.apache.hadoop.mapred.Counters log
INFO:     Map output records=3
14.08.2010 19:08:49 edu.yale.cs.hadoopdb.exec.DBJobBase run
INFO: 
JOB TIME : 1828 ms.


$
</PRE>

<P>
Результат сохранен в HDFS, в папке padraig:
<PRE>
$ cd padraig
$ cat part-00000
some data
$
</PRE>

<P>
Проверим данные в PostgreSQL:
<PRE>
psql&gt; select * from grep where field like '%wo%';
+--------------------------------+-------------------+
| key1                           | field
|
+--------------------------------+-------------------+
some data

1 rows in set (0.00 sec)

psql&gt;
</PRE>

<P>
Значения совадают. Все работает как требуется.

<P>

<H2><A NAME="SECTION00432000000000000000">
Заключение</A>
</H2>
В данной статье не показывается, как настроить Hive для работы с HadoopDB. Эта книга не сможет учесть все, 
что требуется для работы c Hadoop. Назначение этой главы - дать основу для работы с Hadoop и HaddopDB.

<P>
HadoopDB не заменяет Hadoop. Эти системы сосуществуют, позволяя аналитику выбирать соответствующие средства в зависимости 
от имеющихся данных и задач.

<P>
HadoopDB может приблизиться в отношении производительности к параллельным системам 
баз данных, обеспечивая при этом отказоустойчивость и возможность использования в неоднородной среде при тех же правилах 
лицензирования, что и Hadoop. Хотя производительность HadoopDB, вообще говоря, ниже производительности параллельных систем 
баз данных, во многом это объясняется тем, что в PostgreSQL таблицы хранятся не по столбцам, и тем, что в PostgreSQL 
не использовалось сжатие данных. Кроме того, Hadoop и Hive&nbsp;-- это сравнительно молодые проекты с открытыми кодами. 

<P>
В HadoopDB применяется некоторый гибрид подходов параллельных СУБД и Hadoop к анализу данных, позволяющий достичь производительности 
и эффективности параллельных систем баз данных, обеспечивая при этом масштабируемсть, отказоустойчивость и гибкость систем, 
основанных на MapReduce. Способность HadoopDB к прямому включению Hadoop и программного обеспечения СУБД с открытыми исходными 
текстами (без изменения кода) делает HadoopDB особенно пригодной для выполнения крупномасштабного анализа данных в будущих 
рабочих нагрузках.

<H1><A NAME="SECTION00440000000000000000">
Заключение</A>
</H1>
В данной главе расмотрено лиш базовые настройки кластеров БД. 
Про кластеры PostgreSQL потребуется написать отдельную книгу, чтобы растмотреть все шаги с установкой, настройкой и работой кластеров.
Надеюсь, что несмотря на это, информация будет полезна многим читателям.

<H1><A NAME="SECTION00500000000000000000">
PgPool-II</A>
</H1>

<H1><A NAME="SECTION00510000000000000000">
Введение</A>
</H1>
pgpool-II это прослойка, работающая между серверами PostgreSQL и клиентами СУБД PostgreSQL. 
Она предоставляет следующие функции:

<UL>
<LI><SPAN  CLASS="textbf">Объединение соединений</SPAN> 

<P>
pgpool-II сохраняет соединения с серверами PostgreSQL и использует их повторно в случае если новое 
соединение устанавливается с теми же параметрами (т.е. имя пользователя, база данных, версия протокола). 
Это уменьшает накладные расходы на соединения и увеличивает производительность системы вцелом.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Репликация</SPAN> 

<P>
pgpool-II может управлять множеством серверов PostgreSQL. Использование функции репликации данных позволяет 
создание резервной копии данных в реальном времени на  2 или более физических дисков, так что сервис может 
продолжать работать без остановки серверов в случае выхода из строя диска.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Балансировка нагрузки</SPAN>

<P>
Если база данных реплицируется, то выполнение запроса SELECT на любом из серверов вернет одинаковый результат. 
pgpool-II использует преимущество функции репликации для уменьшения нагрузки на каждый из серверов PostgreSQL 
распределяя запросы SELECT на несколько серверов, тем самым увеличивая производительность системы вцелом. 
В лучшем случае производительность возрастает пропорционально числу серверов PostgreSQL. Балансировка нагрузки 
лучше всего работает в случае когда много пользователей выполняют много запросов в одно и тоже время.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Ограничение лишних соединений</SPAN>

<P>
Существует ограничение максимального числа одновременных соединений с PostgreSQL, при превышении которого новые 
соединения отклоняются. Установка максимального числа соединений, в то же время, увеличивает потребление ресурсов и 
снижает производительность системы. pgpool-II также имеет ограничение на максимальное число соединений, но &#171;лишние&#187; 
соединения будут поставлены в очередь вместо немедленного возврата ошибки.

<P>
</LI>
<LI><SPAN  CLASS="textbf">Параллельные запросы</SPAN>

<P>
Используя функцию параллельных запросов можно разнести данные на множество серверов, благодаря чему запрос может 
быть выполнен на всех серверах одновременно для уменьшения общего времени выполнения. Параллельные запросы работают 
лучше всего при поиске в больших объемах данных.
</LI>
</UL>

<P>
pgpool-II общается по протоколу бэкенда и фронтенда PostgreSQL и располагается между ними. 
Таким образом, приложение базы данных (фронтенд) считает что pgpool-II&nbsp;-- настоящий сервер PostgreSQL, а сервер (бэкенд) 
видит pgpool-II как одного из своих клиентов. Поскольку pgpool-II прозрачен как для сервера, так и для клиента, 
существующие приложения, работающие с базой данных, могут использоваться с pgpool-II практически без изменений в исходном коде.

<P>
Оригинал руководства доступен по адресу http://pgpool.projects.postgresql.org/pgpool-II/doc/tutorial-en.html.

<P>

<H1><A NAME="SECTION00520000000000000000"></A>
<A NAME="sec:pgpool-II-begin"></A>
<BR>
Давайте начнем!
</H1>
Перед тем как использовать репликацию или параллельные запросы мы должны научиться устанавливать и настраивать pgpool-II 
и узлы базы данных.

<P>

<H2><A NAME="SECTION00521000000000000000">
Установка pgpool-II</A>
</H2>
Установка pgpool-II очень проста. В каталоге, в который вы распаковали архив 
с исходными текстами, выполните следующие команды.
<PRE>
$ ./configure
$ make
$ make install
</PRE>

<P>
Скрипт configure собирает информацию о вашей системе и использует ее в процедуре компиляции. Вы можете 
указать параметры в командной строке скрипта configure чтобы изменить его поведение по-умолчанию, такие, например, 
как каталог установки. pgpool-II по-умолчанию будет установлен в каталог /usr/local.

<P>
Команда make скомпилирует исходный код, а make install установит исполняемые файлы. У вас должно быть право на 
запись в каталог установки.

<P>
Обратите внимание: для работы pgpool-II необходима библиотека libpq для PostgreSQL 7.4 или более поздней версии (3 версия протокола).
Если скрипт configure выдает следующее сообщение об ошибке, возможно не установлена библиотека libpq или она не 3 версии.
<PRE>
configure: error: libpq is not installed or libpq is old
</PRE>

<P>
Если библиотека 3 версии, но указанное выше сообщение все-таки выдается, ваша библиотека libpq, вероятно, 
не распознается скриптом configure.

<P>
Скрипт configure ищет библиотеку libpq начиная от каталога /usr/local/pgsql. Если вы установили PostgreSQL в каталог 
отличный от /usr/local/pgsql используйте параметры командной строки -with-pgsql или -with-pgsql-includedir вместе с 
параметром -with-pgsql-libdir при запуске скрипта configure.

<P>
Во многих Linux системах pgpool-II может находится в репозитории пакетов. 
Для Ubuntu Linux, например, достаточно будет выполнить:
<PRE>
sudo aptitude install pgpool2
</PRE>

<P>

<H2><A NAME="SECTION00522000000000000000">
Файлы конфигурации</A>
</H2>
Параметры конфигурации pgpool-II хранятся в файле pgpool.conf. Формат файла: одна пара &#171;параметр = значение&#187; в строке. 
При установке pgpool-II автоматически создается файл pgpool.conf.sample. Мы рекомендуем скопировать его в файл pgpool.conf, 
а затем отредактировать по вашему желанию.
<PRE>
$ cp /usr/local/etc/pgpool.conf.sample /usr/local/etc/pgpool.conf
</PRE>

<P>
pgpool-II принимает соединения только с localhost на порт 9999. Если вы хотите принимать соединения с других хостов, 
установите для параметра listen_addresses значение &#171;*&#187;.
<PRE>
listen_addresses = 'localhost'
port = 9999
</PRE>

<P>
Мы будем использовать параметры по-умолчанию в этом руководстве.

<P>
В Ubuntu Linux конфиг находится /etc/pgpool.conf.

<P>

<H2><A NAME="SECTION00523000000000000000">
Настройка команд PCP</A>
</H2>
У pgpool-II есть интерфейс для административных целей&nbsp;-- получить информацию об узлах базы данных, 
остановить pgpool-II и т.д.&nbsp;-- по сети. Чтобы использовать команды PCP, необходима идентификация пользователя. 
Эта идентификация отличается от идентификации пользователей в PostgreSQL. Имя пользователя и пароль нужно указывать в 
файле pcp.conf. В этом файле имя пользователя и пароль указываются как пара значений, разделенных двоеточием (:). 
Одна пара в строке. Пароли зашифрованы в формате хэша md5.
<PRE>
postgres:e8a48653851e28c69d0506508fb27fc5
</PRE>

<P>
При установке pgpool-II автоматически создается файл pcp.conf.sample. 
Мы рекомендуем скопировать его в файл pcp.conf и отредактировать.
<PRE>
$ cp /usr/local/etc/pcp.conf.sample /usr/local/etc/pcp.conf
</PRE>

<P>
В Ubuntu Linux файл находится /etc/pcp.conf.

<P>
Для того чтобы зашифровать ваш пароль в формате хэша md5 используете команду pg_md5, которая устанавливается как один из 
исполняемых файлов pgpool-II. pg_md5 принимает текст в параметре командной строки и отображает текст его md5 хэша.

<P>
Например, укажите &#171;postgres&#187; в качестве параметра командной строки и pg_md5 выведет текст хэша md5 в стандартный поток вывода.
<PRE>
$ /usr/bin/pg_md5 postgres
e8a48653851e28c69d0506508fb27fc5
</PRE>

<P>
Команды PCP выполняются по сети, так что в файле pgpool.conf должен быть указан номер порта в параметре pcp_port.

<P>
Мы будем использовать значение по-умолчанию для параметра pcp_port 9898 в этом руководстве.
<PRE>
pcp_port = 9898
</PRE>

<P>

<H2><A NAME="SECTION00524000000000000000">
Подготовка узлов базы данных</A>
</H2>
Теперь нам нужно настроить серверы бэкендов PostgreSQL для pgpool-II. Эти серверы могут быть размещены на одном 
хосте с pgpool-II или на отдельных машинах. Если вы решите разместить серверы на том же хосте, для всех серверов 
должны быть установлены разные номера портов. Если серверы размещены на отдельных машинах, они должны быть настроены 
так чтобы могли принимать сетевые соединения от pgpool-II.

<P>
В этом руководстве мы разместили три сервера в рамках одного хоста вместе с pgpool-II и присвоили им номера портов 
5432, 5433, 5434 соответственно. Для настройки pgpool-II отредактируйте файл pgpool.conf как показано ниже.
<PRE>
backend_hostname0 = 'localhost'
backend_port0 = 5432
backend_weight0 = 1
backend_hostname1 = 'localhost'
backend_port1 = 5433
backend_weight1 = 1
backend_hostname2 = 'localhost'
backend_port2 = 5434
backend_weight2 = 1
</PRE>

<P>
В параметрах backend_hostname, backend_port, backend_weight укажите имя хоста узла базы данных, номер порта и 
коэффициент для балансировки нагрузки. В конце имени каждого параметра должен быть указан идентификатор узла путем 
добавления положительного целого числа начиная с 0 (т.е. 0, 1, 2).

<P>
Параметры backend_weight все равны 1, что означает что запросы SELECT равномерно распределены по трем серверам.

<P>

<H2><A NAME="SECTION00525000000000000000">
Запуск/Остановка pgpool-II</A>
</H2>
Для старта pgpool-II выполните в терминале следующую команду.
<PRE>
$ pgpool
</PRE>

<P>
Указанная выше команда, однако, не печатает протокол своей работы потому что pgpool отсоединяется от терминала. 
Если вы хотите показать протокол работы pgpool, укажите параметр -n в командной строке при запуске pgpool. 
pgpool-II будет запущен как процесс не-демон и терминал не будет отсоединен.
<PRE>
$ pgpool -n &amp;
</PRE>

<P>
Протокол работы будет печататься на терминал, так что рекомендуемые для использования параметры командной строки, 
например, такие.
<PRE>
$ pgpool -n -d &gt; /tmp/pgpool.log 2&gt;&amp;1 &amp;
</PRE>

<P>
Параметр -d включает генерацию отладочных сообщений.

<P>
Указанная выше команда постоянно добавляет выводимый протокол работы в файл /tmp/pgpool.log. Если вам нужно 
ротировать файлы протоколов, передавайте протоколы внешней команде, у которой есть функция ротации протоколов. 
Вам поможет, например, cronolog.
<PRE>
$ pgpool -n 2&gt;&amp;1 | /usr/sbin/cronolog
  --hardlink=/var/log/pgsql/pgpool.log
  '/var/log/pgsql/%Y-%m-%d-pgpool.log' &amp;
</PRE>

<P>
Чтобы остановить процесс pgpool-II, выполните следующую команду.
<PRE>
$ pgpool stop
</PRE>

<P>
Если какие-то из клиентов все еще присоединены, pgpool-II ждет пока они не отсоединятся и потом завершает свою работу. 
Если вы хотите завершить pgpool-II насильно, используйте вместо этой следующую команду.
<PRE>
$ pgpool -m fast stop
</PRE>

<P>

<H1><A NAME="SECTION00530000000000000000"></A>
<A NAME="sec:pgpool-II-replica"></A>
<BR>
Ваша первая репликация
</H1>
Репликация включает копирование одних и тех же данных на множество узлов базы данных.

<P>
В этом разделе мы будем использовать три узла базы данных, которые мы уже установили в разделе 
&#171;<A HREF="#sec:pgpool-II-begin">4.2 !</A>. Давайте начнем!&#187;, и проведем вас шаг за шагом к созданию системы репликации базы данных. 
Пример данных для репликации будет сгенерирован программой для тестирования pgbench.

<P>

<H2><A NAME="SECTION00531000000000000000">
Настройка репликации</A>
</H2>
Чтобы включить функцию репликации базы данных установите значение true для параметра replication_mode в файле pgpool.conf.
<PRE>
replication_mode = true
</PRE>

<P>
Если параметр replication_mode равен true, pgpool-II будет отправлять копию принятого запроса на все узлы базы данных.

<P>
Если параметр load_balance_mode равен true, pgpool-II будет распределять запросы SELECT между узлами базы данных.
<PRE>
load_balance_mode = true
</PRE>

<P>
В этом разделе мы включили оба параметра replication_mode и load_balance_mode.

<P>

<H2><A NAME="SECTION00532000000000000000">
Проверка репликации</A>
</H2>
Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. 
Пожалуйста обращайтесь к разделу &#171;Запуск/Остановка pgpool-II&#187;.

<P>
После настройки pgpool.conf и перезапуска pgpool-II, давайте проверим репликацию в действии 
и посмотрим все ли работает хорошо.

<P>
Сначала нам нужно создать базу данных, которую будем реплицировать. Назовем ее &#171;bench_replication&#187;. 
Эту базу данных нужно создать на всех узлах. Используйте команду createdb через pgpool-II и база 
данных будет создана на всех узлах.
<PRE>
$ createdb -p 9999 bench_replication
</PRE>

<P>
Затем мы запустим pgbench с параметром -i. Параметр -i инициализирует базу данных предопределенными 
таблицами и данными в них.
<PRE>
$ pgbench -i -p 9999 bench_replication
</PRE>

<P>
Указанная ниже таблица содержит сводную информацию о таблицах и данных, которые будут созданы при помощи pgbench -i. 
Если на всех узлах базы данных перечисленные таблицы и данные были созданы, репликация работает корректно.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">Имя таблицы</TD>
<TD ALIGN="CENTER">Число строк</TD>
</TR>
<TR><TD ALIGN="CENTER">branches</TD>
<TD ALIGN="CENTER">1</TD>
</TR>
<TR><TD ALIGN="CENTER">tellers</TD>
<TD ALIGN="CENTER">10</TD>
</TR>
<TR><TD ALIGN="CENTER">accounts</TD>
<TD ALIGN="CENTER">100000</TD>
</TR>
<TR><TD ALIGN="CENTER">history</TD>
<TD ALIGN="CENTER">0</TD>
</TR>
</TABLE>

<P>
Для проверки указанной выше информации на всех узлах используем простой скрипт на shell. 
Приведенный ниже скрипт покажет число строк в таблицах branches, tellers, accounts и history 
на всех узлах базы данных (5432, 5433, 5434).
<PRE>
$ for port in 5432 5433 5434; do
&gt;     echo $port
&gt;     for table_name in branches tellers accounts history; do
&gt;         echo $table_name
&gt;         psql -c "SELECT count(*) FROM $table_name" -p \
&gt;         $port bench_replication
&gt;     done
&gt; done
</PRE>

<P>

<H1><A NAME="SECTION00540000000000000000">
Ваш первый параллельный запрос</A>
</H1>
Данные из разных диапазонов сохраняются на двух или более узлах базы данных параллельным запросом. 
Это называется распределением (часто используется без перевода термин partitioning прим. переводчика). 
Более того, одни и те же данные на двух и более узлах базы данных могут быть воспроизведены с использованием распределения.

<P>
Чтобы включить параллельные запросы в pgpool-II вы должны установить еще одну базу данных, называемую 
&#171;Системной базой данных&#187; (&#171;System Database&#187;) (далее будем называть ее SystemDB).

<P>
SystemDB хранит определяемые пользователем правила, определяющие какие данные будут сохраняться на каких узлах бызы данных. 
Также SystemDB используется чтобы объединить результаты возвращенные узлами базы данных посредством dblink.

<P>
В этом разделе мы будем использовать три узла базы данных, которые мы установили в разделе &#171;<A HREF="#sec:pgpool-II-begin">4.2 !</A>. 
Давайте начнем!&#187;, и проведем вас шаг за шагом к созданию системы баз данных с параллельными запросами. 
Для создания примера данных мы снова будем использовать pgbench.

<P>

<H2><A NAME="SECTION00541000000000000000">
Настройка параллельного запроса</A>
</H2>
Чтобы включить функцию выполнения параллельных запросов установите для параметра parallel_mode значение true в файле pgpool.conf.
<PRE>
parallel_mode = true
</PRE>

<P>
Установка параметра parallel_mode равным true не запустит параллельные запросы автоматически. 
Для этого pgpool-II нужна SystemDB и правила определяющие как распределять данные по узлам базы данных.

<P>
Также SystemDB использует dblink для создания соединений с pgpool-II. Таким образом, нужно установить значение 
параметра listen_addresses таким образом чтобы pgpool-II принимал эти соединения.
<PRE>
listen_addresses = '*'
</PRE>

<P>
Внимание: Репликация не реализована для таблиц, которые распределяются посредством параллельных запросов и, 
в то же время, репликация может быть успешно осуществлена. Вместе с тем, из-за того что набор хранимых данных 
отличается при параллельных запросах и при репликации, база данных &#171;bench_replication&#187;, созданная в разделе
&#171;<A HREF="#sec:pgpool-II-replica">4.3  </A>. Ваша первая репликация&#187; не может быть повторно использована.
<PRE>
replication_mode = true
load_balance_mode = false
</PRE>
ИЛИ
<PRE>
replication_mode = false
load_balance_mode = true
</PRE>

<P>
В этом разделе мы установим параметры parallel_mode и load_balance_mode равными true, 
listen_addresses равным &#171;*&#187;, replication_mode равным false.

<P>

<H2><A NAME="SECTION00542000000000000000">
Настройка SystemDB</A>
</H2>
В основном, нет отличий между простой и системной базами данных. Однако, в системной базе данных определяется функция 
dblink и присутствует таблица, в которой хранятся правила распределения данных. Таблицу dist_def необходимо определять. 
Более того, один из узлов базы данных может хранить системную базу данных, а pgpool-II может использоваться для 
распределения нагрузки каскадным подключеним.

<P>
В этом разделе мы создадим SystemDB на узле с портом 5432. Далее приведен список параметров конфигурации для SystemDB
<PRE>
system_db_hostname = 'localhost'
system_db_port = 5432
system_db_dbname = 'pgpool'
system_db_schema = 'pgpool_catalog'
system_db_user = 'pgpool'
system_db_password = ''
</PRE>

<P>
На самом деле, указанные выше параметры являются параметрами по-умолчанию в файле pgpool.conf. Теперь мы должны 
создать пользователя с именем &#171;pgpool&#187; и базу данных с именем &#171;pgpool&#187; и владельцем &#171;pgpool&#187;.
<PRE>
$ createuser -p 5432 pgpool
$ createdb -p 5432 -O pgpool pgpool
</PRE>

<P>

<H3><A NAME="SECTION00542100000000000000">
Установка dblink</A>
</H3>
Далее мы должны установить dblink в базу данных &#171;pgpool&#187;. dblink&nbsp;-- один из инструментов включенных в каталог 
contrib исходного кода PostgreSQL.

<P>
Для установки dblink на вашей системе выполните следующие команды.
<PRE>
$ USE_PGXS=1 make -C contrib/dblink
$ USE_PGXS=1 make -C contrib/dblink install
</PRE>

<P>
После того как dblink был установлен в вашей системе мы добавим функции dblink в базу данных &#171;pgpool&#187;. Если PostgreSQL 
установлен в каталог /usr/local/pgsql, dblink.sql (файл с определениями функций) должен быть установлен в каталог 
/usr/local/pgsql/share/contrib. Теперь выполним следующую команду для добавления функций dblink.
<PRE>
$ psql -f /usr/local/pgsql/share/contrib/dblink.sql -p 5432 pgpool
</PRE>

<P>

<H3><A NAME="SECTION00542200000000000000">
Создание таблицы dist_def</A>
</H3>
Следующим шагом мы создадим таблицу с именем &#171;dist_def&#187;, в которой будут храниться правила распределения данных. 
Поскольку pgpool-II уже был установлен, файл с именем system_db.sql должен буть установлен в 
/usr/local/share/system_db.sql (имейте в виду что это учебное руководство и мы использовали для установки каталог 
по-умолчанию – /usr/local). Файл system_db.sql содержит директивы для создания специальных таблиц, включая и 
таблицу &#171;dist_def&#187;. Выполните следующую команду для создания таблицы &#171;dist_def&#187;.
<PRE>
$ psql -f /usr/local/share/system_db.sql -p 5432 -U pgpool pgpool
</PRE>

<P>
Все таблицы в файле system_db.sql, включая &#171;dist_def&#187;, создаются в схеме &#171;pgpool_catalog&#187;. Если вы установили 
параметр system_db_schema на использование другой схемы вам нужно, соответственно, отредактировать файл system_db.sql.

<P>
Описание таблицы &#171;dist_def&#187; выглядит так как показано ниже. Имя таблицы не должно измениться.
<PRE>
CREATE TABLE pgpool_catalog.dist_def (
    dbname text, -- имя базы данных
    schema_name text, -- имя схемы
    table_name text, -- имя таблицы
    col_name text NOT NULL CHECK (col_name = ANY (col_list)), 
    -- столбец-ключ для распределения данных
    col_list text[] NOT NULL, -- список имен столбцов
    type_list text[] NOT NULL, -- список типов столбцов
    dist_def_func text NOT NULL, 
    -- имя функции распределения данных
    PRIMARY KEY (dbname, schema_name, table_name)
);
</PRE>

<P>
Записи, хранимые в таблице &#171;dist_def&#187;, могут быть двух типов.

<UL>
<LI>Правило Распределения Данных (col_name, dist_def_func)
</LI>
<LI>Мета-информация о таблицах (dbname, schema_name, table_name, col_list, type_list)
</LI>
</UL>

<P>
Правило распределения данных определяет как будут распределены данные на конкретный узел базы данных. Данные будут 
распределены в зависимости от значения столбца &#171;col_name&#187;. &#171;dist_def_func&#187;&nbsp;-- это функция, которая принимает 
значение &#171;col_name&#187; в качестве агрумента и возвращает целое число, которое соответствует идентификатору узла 
базы данных, на котором должны быть сохранены данные.

<P>
Мета-информация используется для того чтобы переписывать запросы. Параллельный запрос должен переписывать исходные запросы 
так чтобы результаты, возвращаемые узлами-бэкендами, могли быть объединены в единый результат.

<P>

<H3><A NAME="SECTION00542300000000000000">
Создание таблицы replicate_def</A>
</H3>
В случае если указана таблица, для которой производится репликация в выражение SQL, использующее зарегистрированную в 
dist_def таблицу путем объединения таблиц, информация о таблице, для которой необходимо производить репликацию, 
предварительно регистрируется в таблице с именем replicate_def. Таблица replicate_def уже была создана при обработке
файла system_db.sql во время создания таблицы dist_def. Таблица replicate_def описана так как показано ниже.
<PRE>
CREATE TABLE pgpool_catalog.replicate_def (
    dbname text, -- имя базы данных
    schema_name text, -- имя схемы
    table_name text, -- имя таблицы
    col_list text[] NOT NULL, -- список имен столбцов
    type_list text[] NOT NULL, -- список типов столбцов
    PRIMARY KEY (dbname, schema_name, table_name)
);
</PRE>

<P>

<H2><A NAME="SECTION00543000000000000000">
Установка правил распределения данных</A>
</H2>
В этом учебном руководстве мы определим правила распределения данных, созданных программой pgbench, на три узла 
базы данных. Тестовые данные будут созданы командой &#171;pgbench -i -s 3&#187; (т.е. масштабный коэффициент равен 3). 
Для этого раздела мы создадим новую базу данных с именем &#171;bench_parallel&#187;.

<P>
В каталоге sample исходного кода pgpool-II вы можете найти файл dist_def_pgbench.sql. Мы будем использовать 
этот файл с примером для создания правил распределения для pgbench. Выполните следующую команду в каталоге с распакованным 
исходным кодом pgpool-II.
<PRE>
$ psql -f sample/dist_def_pgbench.sql -p 5432 pgpool
</PRE>

<P>
Ниже представлено описание файла dist_def_pgbench.sql.

<P>
В файле dist_def_pgbench.sql мы добавляем одну строку в таблицу &#171;dist_def&#187;. Это функция распределения данных 
для таблицы accounts. В качестве столбца-ключа указан столбец aid.
<PRE>
INSERT INTO pgpool_catalog.dist_def VALUES (
    'bench_parallel',
    'public',
    'accounts',
    'aid',
    ARRAY['aid', 'bid', 'abalance', 'filler'],
    ARRAY['integer', 'integer', 'integer', 
    'character(84)'],
    'pgpool_catalog.dist_def_accounts'
);
</PRE>

<P>
Теперь мы должны создать функцию распределения данных для таблицы accounts. Заметим, что вы можете использовать 
одну и ту же функцию для разных таблиц. Также вы можете создавать функции с использованием языков отличных от SQL 
(например, PL/pgSQL, PL/Tcl, и т.д.).

<P>
Таблица accounts в момент инициализации данных хранит значение масштабного коэффициента равное 3, значения 
столбца aid от 1 до 300000. Функция создана таким образом что данные равномерно распределяются по трем узлам базы данных.

<P>
Следующая SQL-функция будет возвращать число узлов базы данных.
<PRE>
CREATE OR REPLACE FUNCTION 
pgpool_catalog.dist_def_branches(anyelement)
RETURNS integer AS $$
    SELECT CASE WHEN $1 &gt; 0 AND $1 &lt;= 1 THEN 0
        WHEN $1 &gt; 1 AND $1 &lt;= 2 THEN 1
        ELSE 2
    END;
$$ LANGUAGE sql;
</PRE>

<P>

<H2><A NAME="SECTION00544000000000000000">
Установка правил репликации</A>
</H2>
Правило репликации&nbsp;-- это то что определяет какие таблицы должны быть использованы для выполнения репликации.

<P>
Здесь это сделано при помощи pgbench с зарегистрированными таблицами branches и tellers.

<P>
Как результат, стало возможно создание таблицы accounts и выполнение запросов, использующих таблицы branches и tellers.
<PRE>
INSERT INTO pgpool_catalog.replicate_def VALUES (
    'bench_parallel',
    'public',
    'branches',
    ARRAY['bid', 'bbalance', 'filler'],
    ARRAY['integer', 'integer', 'character(88)']
);

INSERT INTO pgpool_catalog.replicate_def VALUES (
    'bench_parallel',
    'public',
    'tellers',
    ARRAY['tid', 'bid', 'tbalance', 'filler'],
    ARRAY['integer', 'integer', 'integer', 'character(84)']
);
</PRE>

<P>
Подготовленный файл Replicate_def_pgbench.sql находится в каталоге sample. Команда psql запускается с указанием пути к 
исходному коду, определяющему правила репликации, например, как показано ниже.
<PRE>
$ psql -f sample/replicate_def_pgbench.sql -p 5432 pgpool
</PRE>

<P>

<H2><A NAME="SECTION00545000000000000000">
Проверка параллельного запроса</A>
</H2>
Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. 
Пожалуйста обращайтесь к разделу &#171;Запуск/Остановка pgpool-II&#187;.

<P>
После настройки pgpool.conf и перезапуска pgpool-II, давайте проверим хорошо ли работают параллельные запросы.

<P>
Сначала нам нужно создать базу данных, которая будет распределена. Мы назовем ее &#171;bench_parallel&#187;. 
Эту базу данных нужно создать на всех узлах. Используйте команду createdb посредством pgpool-II и база 
данных будет создана на всех узлах.
<PRE>
$ createdb -p 9999 bench_parallel
</PRE>

<P>
Затем запустим pgbench с параметрами -i -s 3. Параметр -i инициализирует базу данных предопределенными 
таблицами и данными. Параметр -s указывает масштабный коэффициент для инициализации.
<PRE>
$ pgbench -i -s 3 -p 9999 bench_parallel
</PRE>

<P>
Созданные таблицы и данные в них показаны в разделе &#171;Установка правил распределения данных&#187;.

<P>
Один из способов проверить корректно ли были распределены данные&nbsp;-- выполнить запрос SELECT посредством 
pgpool-II и напрямую на бэкендах и сравнить результаты. Если все настроено правильно база данных 
&#171;bench_parallel&#187; должна быть распределена как показано ниже.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER">Имя таблицы</TD>
<TD ALIGN="CENTER">Число строк</TD>
</TR>
<TR><TD ALIGN="CENTER">branches</TD>
<TD ALIGN="CENTER">3</TD>
</TR>
<TR><TD ALIGN="CENTER">tellers</TD>
<TD ALIGN="CENTER">30</TD>
</TR>
<TR><TD ALIGN="CENTER">accounts</TD>
<TD ALIGN="CENTER">300000</TD>
</TR>
<TR><TD ALIGN="CENTER">history</TD>
<TD ALIGN="CENTER">0</TD>
</TR>
</TABLE>

<P>
Для проверки указанной выше информации на всех узлах и посредством pgpool-II используем простой скрипт на shell. 
Приведенный ниже скрипт покажет минимальное и максимальное значение в таблице accounts используя для соединения 
порты 5432, 5433, 5434 и 9999.
<PRE>
$ for port in 5432 5433 5434i 9999; do
&gt;     echo $port
&gt;     psql -c "SELECT min(aid), max(aid) FROM accounts" \
&gt;     -p $port bench_parallel
&gt; done
</PRE>

<P>

<H1><A NAME="SECTION00550000000000000000">
Master-slave режим</A>
</H1>
Этот режим предназначен для использования pgpool-II с другой репликацией (например Slony-I, Londiste). 
Информация про БД указывается как для репликации. master_slave_mode и load_balance_mode устанавливается в true. 
pgpool-II будет посылать запросы INSERT/UPDATE/DELETE на Master DB (1 в списке), а SELECT&nbsp;-- использовать балансировку 
нагрузки, если это возможно.

<P>
При этом, DDL и DML для временной таблицы может быть выполнен только на мастере. Если нужен SELECT только на мастере, то для этого 
нужно использовать комментарий /*NO LOAD BALANCE*/ перед SELECT.

<P>
В Master/Slave режиме replication_mode должен быть установлен false, а master_slave_mode&nbsp;-- true.

<P>

<H1><A NAME="SECTION00560000000000000000">
Онлайн востановление</A>
</H1>
pgpool-II, в режиме репликации, может синхронизировать базы данных и добавлять их как ноды к pgpool. 
Называется это &#171;онлайн восстановление&#187;. Этот метод также может быть использован, когда нужно вернуть 
в репликацию упавший нод базы данных.

<P>
В данной статье не будет рассматриватся, как настроить онлайн восстановление. Данную информацию можно подчеркнуть из 
<BR>
http://pgpool.projects.postgresql.org/pgpool-II/doc/pgpool-en.html#online-recovery или 
<BR>
http://pgpool.projects.postgresql.org/contrib_docs/pgpool-II_for_beginners.pdf

<P>

<H1><A NAME="SECTION00570000000000000000">
Заключение</A>
</H1>
PgPool-II&nbsp;-- прекрасное средство, которое нужно применять при масштабировании PostgreSQL.

<H1><A NAME="SECTION00600000000000000000">
Мультиплексоры соединений</A>
</H1>

<H1><A NAME="SECTION00610000000000000000">
Введение</A>
</H1>
Мультиплексоры соединений(программы для создания пула коннектов) позволяют уменьшить накладные расходы на базу данных, 
когда огромное количество физических соединений тянет производительность PostgreSQL вниз. 
Это особенно важно на Windows, когда система ограничивает большое количество соединений. 
Это также важно для веб-приложений, где количество соединений может быть очень большим.

<P>
Программы, которые создают пулы соединений:

<UL>
<LI>PgBouncer
</LI>
<LI>Pgpool
</LI>
</UL>

<P>
Также некоторые администраторы PostgreSQL с успехом используют Memcached для уменьшения работы БД 
за счет кэширования данных.

<P>

<H1><A NAME="SECTION00620000000000000000">
PgBouncer</A>
</H1>
Это мультиплексор соединений для PostgreSQL от компании Skype. Существуют три режима управления.

<UL>
<LI><SPAN  CLASS="textbf">Session Pooling.</SPAN>
Наиболее &#171;вежливый&#187; режим. При начале сессии клиенту выделяется соединение с сервером; 
оно приписано ему в течение всей сессии и возвращается в пул только после отсоединения клиента. 
</LI>
<LI><SPAN  CLASS="textbf">Transaction Pooling.</SPAN> 
Клиент владеет соединением с бакендом только в течение транзакции. Когда PgBouncer замечает, 
что транзакция завершилась, он возвращает соединение назад в пул. 
</LI>
<LI><SPAN  CLASS="textbf">Statement Pooling.</SPAN> 
Наиболее агрессивный режим. Соединение с бакендом возвращается назад в пул сразу после завершения 
запроса. Транзакции с несколькими запросами в этом режиме не разрешены, так как они гарантировано будут отменены.
</LI>
</UL>

<P>
К достоинствам PgBouncer относится:

<UL>
<LI>малое потребление памяти (менее 2 КБ на соединение);
</LI>
<LI>отсутствие привязки к одному серверу баз данных;
</LI>
<LI>реконфигурация настроек без рестарта.
</LI>
</UL>

<P>
Базовая утилита запускается так:
<PRE>
$pgbouncer [-d][-R][-v][-u user] &lt;pgbouncer.ini&gt;
</PRE>

<P>
Простой пример для конфига:
<PRE>
[databases]
template1 = host=127.0.0.1 port=5432 dbname=template1
[pgbouncer]
listen_port = 6543
listen_addr = 127.0.0.1
auth_type = md5
auth_file = userlist.txt
logfile = pgbouncer.log
pidfile = pgbouncer.pid
admin_users = someuser
</PRE>

<P>
Нужно создать файл пользователей userlist.txt примерного содержания:"someuser" "same_password_as_in_server"

<P>
Админский доступ из консоли к базе данных pgbouncer:
<PRE>
$psql -h 127.0.0.1 -p 6543 pgbouncer
</PRE>

<P>
Здесь можно получить различную статистическую информацию с помощью команды SHOW.

<P>

<H1><A NAME="SECTION00630000000000000000">
PgPool-II vs PgBouncer</A>
</H1>

<P>
Все очень просто. PgBouncer намного лучше работает с пулами соединений, чем PgPool-II. Если вам не 
нужны остальные фичи, которыми владеет PgPool-II (ведь пулы коннектов это мелочи к его функционалу), 
то конечно лучше использовать PgBouncer. 

<UL>
<LI>PgBouncer потребляет меньше памяти, чем PgPool-II
</LI>
<LI>у PgBouncer возможно настроить очередь соединений
</LI>
<LI>в PgBouncer можно настраивать псевдо базы данных (на сервере они могут называтся по другому)
</LI>
</UL>

<P>
Хотя некоторые используют PgBouncer и PgPool-II совместно.

<P>

<H1><A NAME="SECTION00700000000000000000">
About this document ...</A>
</H1>
 <STRONG>Postgresql для професионалов</STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2008 (1.71)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
Nikos Drakos, 
Computer Based Learning Unit, University of Leeds.
<BR>
Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-html_version 4.0,latin1,unicode -split 0 postgresql.tex</TT>
<P>
The translation was initiated by leo on 2010-08-15
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot270">... мусор</A><A
 HREF="postgresql.html#tex2html1"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>под которым понимаются 
старые версии изменённых/удалённых записей

</DD>
<DT><A NAME="foot286">... часто</A><A
 HREF="postgresql.html#tex2html2"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>&#171;слишком часто&#187; 
можно определить как &#171;чаще раза в минуту&#187;. Вы также можете задать параметр checkpoint_warning (в секундах): 
в журнал сервера будут писаться предупреждения, если контрольные точки происходят чаще заданного.

</DD>
<DT><A NAME="foot297">... логов</A><A
 HREF="postgresql.html#tex2html3"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>буфер находится в 
разделяемой памяти и является общим для всех процессов

</DD>
<DT><A NAME="foot302">... запроса</A><A
 HREF="postgresql.html#tex2html4"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>Указывает планировщику на размер самого большого объекта в базе данных, который 
теоретически может быть закеширован

</DD>
<DT><A NAME="foot435">... noatime</A><A
 HREF="postgresql.html#tex2html5"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>при этом не будет отслеживаться время последнего доступа к файлу

</DD>
<DT><A NAME="foot437">... дисков</A><A
 HREF="postgresql.html#tex2html6"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>несколько логических разделов на одном диске здесь, 
очевидно, не помогут: головка всё равно будет одна

</DD>
<DT><A NAME="foot470">... pgtune</A><A
 HREF="postgresql.html#tex2html7"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://pgtune.projects.postgresql.org/

</DD>
<DT><A NAME="foot533">... запрос</A><A
 HREF="postgresql.html#tex2html8"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>и поэтому EXPLAIN ANALYZE DELETE ...&nbsp;-- не слишком хорошая идея

</DD>
<DT><A NAME="foot558">... правила</A><A
 HREF="postgresql.html#tex2html9"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>RULE&nbsp;-- реализованное в 
PostgreSQL расширение стандарта SQL, позволяющее, в частности, создавать обновляемые представления

</DD>
<DT><A NAME="foot568">... порядок</A><A
 HREF="postgresql.html#tex2html10"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>&#171;на нашем форуме более 10000 зарегистрированных 
пользователей, оставивших более 50000 сообщений!&#187;

</DD>
<DT><A NAME="foot576">...
pgFouine</A><A
 HREF="postgresql.html#tex2html11"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://pgfouine.projects.postgresql.org/

</DD>
<DT><A NAME="foot664">...Slony-I</A><A
 HREF="postgresql.html#tex2html12"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.slony.info/

</DD>
<DT><A NAME="foot666">...PGCluster</A><A
 HREF="postgresql.html#tex2html13"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://pgfoundry.org/projects/pgcluster/

</DD>
<DT><A NAME="foot668">...pgpool-I/II</A><A
 HREF="postgresql.html#tex2html14"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://pgpool.projects.postgresql.org/

</DD>
<DT><A NAME="foot672">...Bucardo</A><A
 HREF="postgresql.html#tex2html15"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://bucardo.org/

</DD>
<DT><A NAME="foot674">...Londiste</A><A
 HREF="postgresql.html#tex2html16"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://skytools.projects.postgresql.org/doc/londiste.ref.html

</DD>
<DT><A NAME="foot675">... Skytools</A><A
 HREF="postgresql.html#tex2html17"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://pgfoundry.org/projects/skytools/

</DD>
<DT><A NAME="foot677">... Replicator</A><A
 HREF="postgresql.html#tex2html18"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.commandprompt.com/products/mammothreplicator/

</DD>
<DT><A NAME="foot679">...Postgres-R</A><A
 HREF="postgresql.html#tex2html19"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.postgres-r.org/

</DD>
<DT><A NAME="foot681">...RubyRep</A><A
 HREF="postgresql.html#tex2html20"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.rubyrep.org/

</DD>
<DT><A NAME="foot896">... реализовать</A><A
 HREF="postgresql.html#tex2html21"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://skytools.projects.postgresql.org/skytools-3.0/doc/skytools3.html

</DD>
<DT><A NAME="foot1067">... исходников</A><A
 HREF="postgresql.html#tex2html22"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://search.cpan.org/CPAN/authors/id/T/TU/TURNSTEP/

</DD>
<DT><A NAME="foot1070">... Скачиваем</A><A
 HREF="postgresql.html#tex2html23"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://bucardo.org/wiki/Bucardo#Obtaining_Bucardo

</DD>
<DT><A NAME="foot1189">... Rubyforge</A><A
 HREF="postgresql.html#tex2html24"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://rubyforge.org/frs/?group_id=7932, выберите ZIP

</DD>
<DT><A NAME="foot1280">... Database</A><A
 HREF="postgresql.html#tex2html25"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.greenplum.com/index.php?page=greenplum-database

</DD>
<DT><A NAME="foot1282">... Server</A><A
 HREF="postgresql.html#tex2html26"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.enterprisedb.com/products/gridsql.do

</DD>
<DT><A NAME="foot1284">...PL/Proxy</A><A
 HREF="postgresql.html#tex2html27"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://plproxy.projects.postgresql.org/doc/tutorial.html

</DD>
<DT><A NAME="foot1286">...HadoopDB</A><A
 HREF="postgresql.html#tex2html28"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://db.cs.yale.edu/hadoopdb/hadoopdb.html

</DD>
<DT><A NAME="foot1303">... PL/Proxy</A><A
 HREF="postgresql.html#tex2html29"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://pgfoundry.org/projects/plproxy

</DD>
<DT><A NAME="foot1445">... HaddopDB</A><A
 HREF="postgresql.html#tex2html31"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://sourceforge.net/projects/hadoopdb/files/

</DD>
<DT><A NAME="foot1448">... её</A><A
 HREF="postgresql.html#tex2html32"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://jdbc.postgresql.org/download.html

</DD>
</DL>
<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="/usr/share/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="/usr/share/latex2html/icons/prev_g.png">   
<BR></DIV>
<!--End of Navigation Panel-->
<ADDRESS>
leo
2010-08-15
</ADDRESS>
</BODY>
</HTML>
