\section{Londiste}
\label{sec:londiste}

\subsection{Введение}
Londiste представляет собой движок для организации репликации, написанный на языке python.
Основные принципы: надежность и простота использования. Из-за этого данное решение имеет меньше функциональности,
чем Slony-I. Londiste использует в качестве транспортного механизма очередь PgQ  (описание этого более чем интересного
проекта остается за рамками данной главы, поскольку он представляет интерес скорее для низкоуровневых программистов
баз данных, чем для конечных пользователей~--- администраторов СУБД PostgreSQL). Отличительными особенностями решения являются:

\begin{itemize}
  \item возможность потабличной репликации
  \item начальное копирование ничего не блокирует
  \item возможность двухстороннего сравнения таблиц
  \item простота установки
\end{itemize}

К недостаткам можно отнести:

\begin{itemize}
  \item триггерная репликация, что ухудшает производительность базы
\end{itemize}


\subsection{Установка}
На серверах, которые мы настраиваем рассматривается ОС Linux, а именно Ubuntu Server.
Автор данной книги считает, что под другие операционные системы (кроме Windows) все мало чем будет отличаться,
а держать кластера PostgreSQL под ОС Windows, по меньшей мере, неразумно.

Поскольку Londiste~--- это часть Skytools, то нам нужно ставить этот пакет. На таких системах, как Debian или Ubuntu skytools
можно найти в репозитории пакетов и поставить одной командой:
\begin{lstlisting}[label=lst:londiste1,caption=Установка]
% sudo aptitude install skytools
\end{lstlisting}

Но в системных пакетах может содержатся версия 2.x, которая не поддерживает каскадную репликацию, отказоустойчивость(failover) и переключение между серверами (switchover). По этой причине я не буду её рассматривать. Скачать самую последнюю версию пакета можно с \href{http://pgfoundry.org/projects/skytools}{официального сайта}.
На момент написания главы последняя версия была 3.2. Итак, начнем:

\begin{lstlisting}[label=lst:londiste2,caption=Установка]
$ wget http://pgfoundry.org/frs/download.php/3622/skytools-3.2.tar.gz
$ tar zxvf skytools-3.2.tar.gz
$ cd skytools-3.2/
# пакеты для сборки deb
$ sudo aptitude install build-essential autoconf \
automake autotools-dev dh-make \
debhelper devscripts fakeroot xutils lintian pbuilder \
python-all-dev python-support xmlto asciidoc \
libevent-dev libpq-dev libtool
# python-psycopg нужен для работы Londiste
$ sudo aptitude install python-psycopg2 postgresql-server-dev-all
# данной командой собираем deb пакет
$ make deb
$ cd ../
# ставим skytools
$ dpkg -i *.deb
\end{lstlisting}

Для других систем можно собрать Skytools командами:

\begin{lstlisting}[label=lst:londiste3,caption=Установка]
$ ./configure
$ make
$ make install
\end{lstlisting}

Дальше проверим, что все у нас правильно установилось
\begin{lstlisting}[label=lst:londiste4,caption=Установка]
$ londiste3 -V
londiste3, Skytools version 3.2
$ pgqd -V
bad switch: usage: pgq-ticker [switches] config.file
Switches:
  -v        Increase verbosity
  -q        No output to console
  -d        Daemonize
  -h        Show help
  -V        Show version
 --ini      Show sample config file
  -s        Stop - send SIGINT to running process
  -k        Kill - send SIGTERM to running process
  -r        Reload - send SIGHUP to running process
\end{lstlisting}

Если у Вас похожий вывод, значит все установлено правильно и можно приступать к настройке.


\subsection{Настройка}

Обозначения:
\begin{itemize}
  \item master-host~--- мастер база данных;
  \item slave1-host, slave2-host~--- слейв базы данных;
  \item l3simple - название реплицируемой базы данных;
\end{itemize}

\subsubsection{Создаём конфигурацию репликатора}
Для начала создадим конфигурационный файл для master базы
(пусть конфиг будет у нас /etc/skytools/master-londiste.ini):
\begin{lstlisting}[label=lst:londiste-replica1,caption=Создаём конфигурацию репликатора]
[londiste3]
job_name = master_l3simple
db = dbname=l3simple
queue_name = replika
logfile = /var/log/skytools/master_l3simple.log
pidfile = /var/pid/skytools/master_l3simple.pid

# Задержка между проверками наличия активности
# (новых пакетов данных) в секундах
loop_delay = 0.5
\end{lstlisting}

Инициализируем Londiste для master базы:

\begin{lstlisting}[label=lst:londiste-replica2,caption=Инициализируем Londiste]
$ londiste3 /etc/skytools/master-londiste.ini create-root master-node "dbname=l3simple host=master-host"
INFO plpgsql is installed
INFO Installing pgq
INFO   Reading from /usr/share/skytools3/pgq.sql
INFO pgq.get_batch_cursor is installed
INFO Installing pgq_ext
INFO   Reading from /usr/share/skytools3/pgq_ext.sql
INFO Installing pgq_node
INFO   Reading from /usr/share/skytools3/pgq_node.sql
INFO Installing londiste
INFO   Reading from /usr/share/skytools3/londiste.sql
INFO londiste.global_add_table is installed
INFO Initializing node
INFO Location registered
INFO Node "master-node" initialized for queue "replika" with type "root"
INFO Done
\end{lstlisting}

master-server~--- это имя провайдера (мастера базы).

Теперь можем запустить демон:

\begin{lstlisting}[label=lst:londiste-replica3,caption=Запускаем демон для master базы]
$ londiste3 -d /etc/skytools/master-londiste.ini worker
$ tail -f /var/log/skytools/master_l3simple.log
INFO {standby: 1}
INFO {standby: 1}
\end{lstlisting}

Если нужно перегрузить демон (например, изменили конфиг), то можно воспользоватся параметром <<-r>>:

\begin{lstlisting}[label=lst:londiste-replica4,caption=Перегрузка демона]
$ londiste3 /etc/skytools/master-londiste.ini -r
\end{lstlisting}

Для остановки демона есть параметр <<-s>>:
\begin{lstlisting}[label=lst:londiste-replica5,caption=Остановка демона]
$ londiste3 /etc/skytools/master-londiste.ini -s
\end{lstlisting}

или если потребуется <<убить>> (kill -9) демон:
\begin{lstlisting}[label=lst:londiste-replica6,caption=Остановка демона]
$ londiste3 /etc/skytools/master-londiste.ini -k
\end{lstlisting}

Для автоматизации этого процесса skytools3 имеет встроенный демон, который подымает все воркеры из директории /etc/skytools/. Сама конфигурация демона находится в /etc/skytools.ini. Что бы запустить все демоны londiste достаточно выполнить:

\begin{lstlisting}[label=lst:londiste-replica7,caption=Демон для ticker]
$ /etc/init.d/skytools3 start
INFO Starting master_l3simple
\end{lstlisting}

Перейдем к slave базе.


\subsubsection{Восстанавливаем схему базы}
Londiste не умеет переносить изменения структуры базы данных.
Поэтому на всех slave базах перед репликацией должна быть создана такая же структура БД, что и на мастере. Пример копирования структуры базы:

\begin{lstlisting}[label=lst:londiste-schema1,caption=Копирования структуры базы]
$ pg_dump -s l3simple | psql -h slave1-host -U postgres l3simple
$ pg_dump -s l3simple | psql -h slave2-host -U postgres l3simple
\end{lstlisting}

Подключение должно быть <<trust>> между master и slave базами данных.












\subsubsection{Устанавливаем Londiste в базы на мастере и слейве}
Теперь необходимо установить служебный SQL для каждой из созданных в предыдущем
пункте конфигураций.

Устанавливаем код на стороне мастера:
\begin{lstlisting}[label=lst:londiste10,caption=Londiste]
londiste.py /etc/skytools/db1-londiste.ini provider install
\end{lstlisting}
и подобным образом на стороне слейва:
\begin{lstlisting}[label=lst:londiste11,caption=Londiste]
londiste.py /etc/skytools/db1-londiste.ini subscriber install
\end{lstlisting}

После этого пункта на мастере будут созданы очереди для репликации.

\subsubsection{Запускаем процессы Londiste}
Для каждой реплицируемой базы делаем:
\begin{lstlisting}[label=lst:londiste12,caption=Запускаем]
londiste.py /etc/skytools/db1-londiste.ini replay -d
\end{lstlisting}

Таким образом запустятся слушатели очередей репликации, но, т.к. мы ещё не
указывали какие таблицы хотим реплицировать, они пока будут работать в холостую.

Убедимся что в логах нет ошибок (/var/log/db1-londistes.log).

\subsubsection{Добавляем реплицируемые таблицы}
Для каждой конфигурации указываем что будем реплицировать с мастера:
\begin{lstlisting}[label=lst:londiste13,caption=Добавляем реплицируемые таблицы]
londiste.py /etc/skytools/db1-londiste.ini provider add --all
\end{lstlisting}
и что со слейва:
\begin{lstlisting}[label=lst:londiste14,caption=Добавляем реплицируемые таблицы]
londiste.py /etc/skytools/db1-londiste.ini subscriber add --all
\end{lstlisting}

В данном примере я использую спец-параметр <<--all>>, который означает все таблицы,
но вместо него вы можете перечислить список конкретных таблиц, если не хотите
реплицировать все.

\subsubsection{Добавляем реплицируемые последовательности (sequence)}
Так же для всех конфигураций.
Для мастера:
\begin{lstlisting}[label=lst:londiste15,caption=Добавляем последовательности]
londiste.py /etc/skytools/db1-londiste.ini provider add-seq --all
\end{lstlisting}
Для слейва:
\begin{lstlisting}[label=lst:londiste16,caption=Добавляем реплицируемые таблицы]
londiste.py /etc/skytools/db1-londiste.ini subscriber add-seq --all
\end{lstlisting}

Точно также как и с таблицами можно указать конкретные последовательности вместо <<--all>>.

\subsubsection{Проверка}
Итак, всё что надо сделано. Теперь Londiste запустит так называемый bulk copy
процесс, который массово (с помощью COPY) зальёт присутствующие на момент
добавления таблиц данные на слейв, а затем перейдёт в состояние обычной репликации.

Мониторим логи на предмет ошибок:
\begin{lstlisting}[label=lst:londiste17,caption=Проверка]
less /var/log/db1-londiste.log
\end{lstlisting}

Если всё хорошо, смотрим состояние репликации. Данные уже синхронизированы для
тех таблиц, где статус отображается как <<ok>>.
\begin{lstlisting}[label=lst:londiste18,caption=Проверка]
londiste.py /etc/skytools/db1-londiste.ini subscriber tables

   Table State
   public.table1 ok
   public.table2 ok
   public.table3 in-copy
   public.table4 -
   public.table5 -
   public.table6 -
   ...
\end{lstlisting}

Для удобства представляю следующий трюк с уведомление в почту об окончании
первоначального копирования (мыло поменять на своё):
\begin{lstlisting}[label=lst:londiste19,caption=Проверка]
(
while [ $(
python londiste.py /etc/skytools/db1-londiste.ini subscriber tables |
tail -n+2 | awk '{print $2}' | grep -v ok | wc -l) -ne 0 ];
do sleep 60; done; echo '' | mail -s 'Replication done EOM' user@domain.com
) &
\end{lstlisting}


\subsection{Общие задачи}

\subsubsection{Добавление всех таблиц мастера слейву}
Просто используя эту команду:
\begin{lstlisting}[label=lst:londiste20,caption=Добавление всех таблиц мастера слейву]
londiste.py <ini> provider tables | xargs londiste.py <ini> subscriber add
\end{lstlisting}

\subsubsection{Проверка состояния слейвов}
Этот запрос на мастере дает некоторую информацию о каждой очереди и слейве.
\begin{lstlisting}[language=SQL,label=lst:londiste21,caption=Проверка состояния слейвов]
SELECT queue_name, consumer_name, lag, last_seen
  FROM pgq.get_consumer_info();
\end{lstlisting}

<<lag>> столбец показывает отставание от мастера в синхронизации,
<<last\_seen>>~--- время последней запроса от слейва. Значение этого столбца не должно быть больше,
чем 60 секунд для конфигурации по умолчанию.

\subsubsection{Удаление очереди всех событий из мастера}
При работе с Londiste может потребоваться удалить все ваши настройки для того, чтобы начать все заново.
Для PGQ, чтобы остановить накопление данных, используйте следующие API:
\begin{lstlisting}[label=lst:londiste22,caption=Удаление очереди всех событий из мастера]
SELECT pgq.unregister_consumer('queue_name', 'consumer_name');
\end{lstlisting}

Или воспользуйтесь pgqadm.py:
\begin{lstlisting}[label=lst:londiste23,caption=Удаление очереди всех событий из мастера]
pgqadm.py <ticker.ini> unregister queue_name consumer_name
\end{lstlisting}

\subsubsection{Добавление столбца в таблицу}
Добавляем в следующей последовательности:
\begin{enumerate}
 \item добавить поле на все слейвы
 \item BEGIN; -- на мастере
 \item добавить поле на мастере
 \item SELECT londiste.provider\_refresh\_trigger('queue\_name', 'tablename');
 \item COMMIT;
\end{enumerate}

\subsubsection{Удаление столбца из таблицы}
\begin{enumerate}
 \item BEGIN; -- на мастере
 \item удалить поле на мастере
 \item SELECT londiste.provider\_refresh\_trigger('queue\_name', 'tablename');
 \item COMMIT;
 \item Проверить <<lag>>, когда londiste пройдет момент удаления поля
 \item удалить поле на всех слейвах
\end{enumerate}

Хитрость тут в том, чтобы удалить поле на слейвах только тогда, когда больше нет событий в очереди на это поле.


\subsection{Устранение неисправностей}

\subsubsection{Londiste пожирает процессор и lag растет}
Это происходит, например, если во время сбоя админ забыл перезапустить ticker. Или когда вы сделали большой
UPDATE или DELETE в одной транзакции, но теперь что бы реализовать каждое событие в этом запросе создаются
транзакции на слейвах \dots

Следующий запрос позволяет подсчитать, сколько событий пришло в pgq.subscription в колонках sub\_last\_tick и sub\_next\_tick.
\begin{lstlisting}[language=SQL,label=lst:londiste24,caption=Устранение неисправностей]
SELECT count(*)
  FROM pgq.event_1,
    (SELECT tick_snapshot
      FROM pgq.tick
      WHERE tick_id BETWEEN 5715138 AND 5715139
    ) as t(snapshots)
WHERE txid_visible_in_snapshot(ev_txid, snapshots);
\end{lstlisting}

В нашем случае, это было более чем 5 миллионов и 400 тысяч событий. Многовато. Чем больше событий
с базы данных требуется обработать Londiste, тем больше ему требуется памяти для этого. Мы можем сообщить
Londiste не загружать все события сразу. Достаточно добавить в INI конфиг ticker-а следующую настройку:
\begin{lstlisting}[label=lst:londiste25,caption=Устранение неисправностей]
pgq_lazy_fetch = 500
\end{lstlisting}

Теперь Londiste будет брать максимум 500 событий в один пакет запросов. Остальные попадут в следующие пакеты запросов.