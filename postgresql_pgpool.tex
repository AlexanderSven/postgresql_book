\chapter{PgPool-II}
\section{Введение}
pgpool-II это прослойка, работающая между серверами PostgreSQL и клиентами СУБД PostgreSQL. 
Она предоставляет следующие функции:
\begin{itemize}
\item \textbf{Объединение соединений} 

pgpool-II сохраняет соединения с серверами PostgreSQL и использует их повторно в случае если новое 
соединение устанавливается с теми же параметрами (т.е. имя пользователя, база данных, версия протокола). 
Это уменьшает накладные расходы на соединения и увеличивает производительность системы вцелом.

\item \textbf{Репликация} 

pgpool-II может управлять множеством серверов PostgreSQL. Использование функции репликации данных позволяет 
создание резервной копии данных в реальном времени на  2 или более физических дисков, так что сервис может 
продолжать работать без остановки серверов в случае выхода из строя диска.

\item \textbf{Балансировка нагрузки}

Если база данных реплицируется, то выполнение запроса SELECT на любом из серверов вернет одинаковый результат. 
pgpool-II использует преимущество функции репликации для уменьшения нагрузки на каждый из серверов PostgreSQL 
распределяя запросы SELECT на несколько серверов, тем самым увеличивая производительность системы вцелом. 
В лучшем случае производительность возрастает пропорционально числу серверов PostgreSQL. Балансировка нагрузки 
лучше всего работает в случае когда много пользователей выполняют много запросов в одно и тоже время.

\item \textbf{Ограничение лишних соединений}

Существует ограничение максимального числа одновременных соединений с PostgreSQL, при превышении которого новые 
соединения отклоняются. Установка максимального числа соединений, в то же время, увеличивает потребление ресурсов и 
снижает производительность системы. pgpool-II также имеет ограничение на максимальное число соединений, но <<лишние>> 
соединения будут поставлены в очередь вместо немедленного возврата ошибки.

\item \textbf{Параллельные запросы}

Используя функцию параллельных запросов можно разнести данные на множество серверов, благодаря чему запрос может 
быть выполнен на всех серверах одновременно для уменьшения общего времени выполнения. Параллельные запросы работают 
лучше всего при поиске в больших объемах данных.
\end{itemize}

pgpool-II общается по протоколу бэкенда и фронтенда PostgreSQL и располагается между ними. 
Таким образом, приложение базы данных (фронтенд) считает что pgpool-II~--- настоящий сервер PostgreSQL, а сервер (бэкенд) 
видит pgpool-II как одного из своих клиентов. Поскольку pgpool-II прозрачен как для сервера, так и для клиента, 
существующие приложения, работающие с базой данных, могут использоваться с pgpool-II практически без изменений в исходном коде.

Оригинал руководства доступен по адресу http://pgpool.projects.postgresql.org/pgpool-II/doc/tutorial-en.html.

\section{Давайте начнем!}
\label{sec:pgpool-II-begin}
Перед тем как использовать репликацию или параллельные запросы мы должны научиться устанавливать и настраивать pgpool-II 
и узлы базы данных.

\subsection{Установка pgpool-II}
Установка pgpool-II очень проста. В каталоге, в который вы распаковали архив 
с исходными текстами, выполните следующие команды.
\begin{verbatim}
$ ./configure
$ make
$ make install
\end{verbatim}

Скрипт configure собирает информацию о вашей системе и использует ее в процедуре компиляции. Вы можете 
указать параметры в командной строке скрипта configure чтобы изменить его поведение по-умолчанию, такие, например, 
как каталог установки. pgpool-II по-умолчанию будет установлен в каталог /usr/local.

Команда make скомпилирует исходный код, а make install установит исполняемые файлы. У вас должно быть право на 
запись в каталог установки.

Обратите внимание: для работы pgpool-II необходима библиотека libpq для PostgreSQL 7.4 или более поздней версии (3 версия протокола).
Если скрипт configure выдает следующее сообщение об ошибке, возможно не установлена библиотека libpq или она не 3 версии.
\begin{verbatim}
configure: error: libpq is not installed or libpq is old
\end{verbatim}

Если библиотека 3 версии, но указанное выше сообщение все-таки выдается, ваша библиотека libpq, вероятно, 
не распознается скриптом configure.

Скрипт configure ищет библиотеку libpq начиная от каталога /usr/local/pgsql. Если вы установили PostgreSQL в каталог 
отличный от /usr/local/pgsql используйте параметры командной строки --with-pgsql или --with-pgsql-includedir вместе с 
параметром --with-pgsql-libdir при запуске скрипта configure.

Во многих Linux системах pgpool-II может находится в репозитории пакетов. 
Для Ubuntu Linux, например, достаточно будет выполнить:
\begin{verbatim}
sudo aptitude install pgpool2
\end{verbatim}

\subsection{Файлы конфигурации}
Параметры конфигурации pgpool-II хранятся в файле pgpool.conf. Формат файла: одна пара <<параметр = значение>> в строке. 
При установке pgpool-II автоматически создается файл pgpool.conf.sample. Мы рекомендуем скопировать его в файл pgpool.conf, 
а затем отредактировать по вашему желанию.
\begin{verbatim}
$ cp /usr/local/etc/pgpool.conf.sample /usr/local/etc/pgpool.conf
\end{verbatim}

pgpool-II принимает соединения только с localhost на порт 9999. Если вы хотите принимать соединения с других хостов, 
установите для параметра listen\_addresses значение <<*>>.
\begin{verbatim}
listen_addresses = 'localhost'
port = 9999
\end{verbatim}

Мы будем использовать параметры по-умолчанию в этом руководстве.

В Ubuntu Linux конфиг находится /etc/pgpool.conf.

\subsection{Настройка команд PCP}
У pgpool-II есть интерфейс для административных целей~--- получить информацию об узлах базы данных, 
остановить pgpool-II и т.д.~--- по сети. Чтобы использовать команды PCP, необходима идентификация пользователя. 
Эта идентификация отличается от идентификации пользователей в PostgreSQL. Имя пользователя и пароль нужно указывать в 
файле pcp.conf. В этом файле имя пользователя и пароль указываются как пара значений, разделенных двоеточием (:). 
Одна пара в строке. Пароли зашифрованы в формате хэша md5.
\begin{verbatim}
postgres:e8a48653851e28c69d0506508fb27fc5
\end{verbatim}

При установке pgpool-II автоматически создается файл pcp.conf.sample. 
Мы рекомендуем скопировать его в файл pcp.conf и отредактировать.
\begin{verbatim}
$ cp /usr/local/etc/pcp.conf.sample /usr/local/etc/pcp.conf
\end{verbatim}

В Ubuntu Linux файл находится /etc/pcp.conf.

Для того чтобы зашифровать ваш пароль в формате хэша md5 используете команду pg\_md5, которая устанавливается как один из 
исполняемых файлов pgpool-II. pg\_md5 принимает текст в параметре командной строки и отображает текст его md5 хэша.

Например, укажите <<postgres>> в качестве параметра командной строки и pg\_md5 выведет текст хэша md5 в стандартный поток вывода.
\begin{verbatim}
$ /usr/bin/pg_md5 postgres
e8a48653851e28c69d0506508fb27fc5
\end{verbatim}

Команды PCP выполняются по сети, так что в файле pgpool.conf должен быть указан номер порта в параметре pcp\_port.

Мы будем использовать значение по-умолчанию для параметра pcp\_port 9898 в этом руководстве.
\begin{verbatim}
pcp_port = 9898
\end{verbatim}


\subsection{Подготовка узлов базы данных}
Теперь нам нужно настроить серверы бэкендов PostgreSQL для pgpool-II. Эти серверы могут быть размещены на одном 
хосте с pgpool-II или на отдельных машинах. Если вы решите разместить серверы на том же хосте, для всех серверов 
должны быть установлены разные номера портов. Если серверы размещены на отдельных машинах, они должны быть настроены 
так чтобы могли принимать сетевые соединения от pgpool-II.

В этом руководстве мы разместили три сервера в рамках одного хоста вместе с pgpool-II и присвоили им номера портов 
5432, 5433, 5434 соответственно. Для настройки pgpool-II отредактируйте файл pgpool.conf как показано ниже.
\begin{verbatim}
backend_hostname0 = 'localhost'
backend_port0 = 5432
backend_weight0 = 1
backend_hostname1 = 'localhost'
backend_port1 = 5433
backend_weight1 = 1
backend_hostname2 = 'localhost'
backend_port2 = 5434
backend_weight2 = 1
\end{verbatim}

В параметрах backend\_hostname, backend\_port, backend\_weight укажите имя хоста узла базы данных, номер порта и 
коэффициент для балансировки нагрузки. В конце имени каждого параметра должен быть указан идентификатор узла путем 
добавления положительного целого числа начиная с 0 (т.е. 0, 1, 2).

Параметры backend\_weight все равны 1, что означает что запросы SELECT равномерно распределены по трем серверам.

\subsection{Запуск/Остановка pgpool-II}
Для старта pgpool-II выполните в терминале следующую команду.
\begin{verbatim}
$ pgpool
\end{verbatim}

Указанная выше команда, однако, не печатает протокол своей работы потому что pgpool отсоединяется от терминала. 
Если вы хотите показать протокол работы pgpool, укажите параметр -n в командной строке при запуске pgpool. 
pgpool-II будет запущен как процесс не-демон и терминал не будет отсоединен.
\begin{verbatim}
$ pgpool -n &
\end{verbatim}

Протокол работы будет печататься на терминал, так что рекомендуемые для использования параметры командной строки, 
например, такие.
\begin{verbatim}
$ pgpool -n -d > /tmp/pgpool.log 2>&1 &
\end{verbatim}

Параметр -d включает генерацию отладочных сообщений.

Указанная выше команда постоянно добавляет выводимый протокол работы в файл /tmp/pgpool.log. Если вам нужно 
ротировать файлы протоколов, передавайте протоколы внешней команде, у которой есть функция ротации протоколов. 
Вам поможет, например, cronolog.
\begin{verbatim}
$ pgpool -n 2>&1 | /usr/sbin/cronolog
  --hardlink=/var/log/pgsql/pgpool.log
  '/var/log/pgsql/%Y-%m-%d-pgpool.log' &
\end{verbatim}

Чтобы остановить процесс pgpool-II, выполните следующую команду.
\begin{verbatim}
$ pgpool stop
\end{verbatim}

Если какие-то из клиентов все еще присоединены, pgpool-II ждет пока они не отсоединятся и потом завершает свою работу. 
Если вы хотите завершить pgpool-II насильно, используйте вместо этой следующую команду.
\begin{verbatim}
$ pgpool -m fast stop
\end{verbatim}

\section{Ваша первая репликация}
\label{sec:pgpool-II-replica}
Репликация включает копирование одних и тех же данных на множество узлов базы данных.

В этом разделе мы будем использовать три узла базы данных, которые мы уже установили в разделе 
<<\ref{sec:pgpool-II-begin}. Давайте начнем!>>, и проведем вас шаг за шагом к созданию системы репликации базы данных. 
Пример данных для репликации будет сгенерирован программой для тестирования pgbench.

\subsection{Настройка репликации}
Чтобы включить функцию репликации базы данных установите значение true для параметра replication\_mode в файле pgpool.conf.
\begin{verbatim}
replication_mode = true
\end{verbatim}

Если параметр replication\_mode равен true, pgpool-II будет отправлять копию принятого запроса на все узлы базы данных.

Если параметр load\_balance\_mode равен true, pgpool-II будет распределять запросы SELECT между узлами базы данных.
\begin{verbatim}
load_balance_mode = true
\end{verbatim}

В этом разделе мы включили оба параметра replication\_mode и load\_balance\_mode.

\subsection{Проверка репликации}
Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. 
Пожалуйста обращайтесь к разделу <<Запуск/Остановка pgpool-II>>.

После настройки pgpool.conf и перезапуска pgpool-II, давайте проверим репликацию в действии 
и посмотрим все ли работает хорошо.

Сначала нам нужно создать базу данных, которую будем реплицировать. Назовем ее <<bench\_replication>>. 
Эту базу данных нужно создать на всех узлах. Используйте команду createdb через pgpool-II и база 
данных будет создана на всех узлах.
\begin{verbatim}
$ createdb -p 9999 bench_replication
\end{verbatim}

Затем мы запустим pgbench с параметром -i. Параметр -i инициализирует базу данных предопределенными 
таблицами и данными в них.
\begin{verbatim}
$ pgbench -i -p 9999 bench_replication
\end{verbatim}

Указанная ниже таблица содержит сводную информацию о таблицах и данных, которые будут созданы при помощи pgbench -i. 
Если на всех узлах базы данных перечисленные таблицы и данные были созданы, репликация работает корректно.

\begin{tabular}{ | c | c | }
  \hline
  Имя таблицы & Число строк \\
  \hline
  branches & 1 \\
  \hline
  tellers & 10 \\
  \hline
  accounts & 100000 \\
  \hline
  history & 0 \\
  \hline
\end{tabular}

Для проверки указанной выше информации на всех узлах используем простой скрипт на shell. 
Приведенный ниже скрипт покажет число строк в таблицах branches, tellers, accounts и history 
на всех узлах базы данных (5432, 5433, 5434).
\begin{verbatim}
$ for port in 5432 5433 5434; do
>     echo $port
>     for table_name in branches tellers accounts history; do
>         echo $table_name
>         psql -c "SELECT count(*) FROM $table_name" -p \
>         $port bench_replication
>     done
> done
\end{verbatim}


\section{Ваш первый параллельный запрос}
Данные из разных диапазонов сохраняются на двух или более узлах базы данных параллельным запросом. 
Это называется распределением (часто используется без перевода термин partitioning прим. переводчика). 
Более того, одни и те же данные на двух и более узлах базы данных могут быть воспроизведены с использованием распределения.

Чтобы включить параллельные запросы в pgpool-II вы должны установить еще одну базу данных, называемую 
<<Системной базой данных>> (<<System Database>>) (далее будем называть ее SystemDB).

SystemDB хранит определяемые пользователем правила, определяющие какие данные будут сохраняться на каких узлах бызы данных. 
Также SystemDB используется чтобы объединить результаты возвращенные узлами базы данных посредством dblink.

В этом разделе мы будем использовать три узла базы данных, которые мы установили в разделе <<\ref{sec:pgpool-II-begin}. 
Давайте начнем!>>, и проведем вас шаг за шагом к созданию системы баз данных с параллельными запросами. 
Для создания примера данных мы снова будем использовать pgbench.

\subsection{Настройка параллельного запроса}
Чтобы включить функцию выполнения параллельных запросов установите для параметра parallel\_mode значение true в файле pgpool.conf.
\begin{verbatim}
parallel_mode = true
\end{verbatim}

Установка параметра parallel\_mode равным true не запустит параллельные запросы автоматически. 
Для этого pgpool-II нужна SystemDB и правила определяющие как распределять данные по узлам базы данных.

Также SystemDB использует dblink для создания соединений с pgpool-II. Таким образом, нужно установить значение 
параметра listen\_addresses таким образом чтобы pgpool-II принимал эти соединения.
\begin{verbatim}
listen_addresses = '*'
\end{verbatim}

Внимание: Репликация не реализована для таблиц, которые распределяются посредством параллельных запросов и, 
в то же время, репликация может быть успешно осуществлена. Вместе с тем, из-за того что набор хранимых данных 
отличается при параллельных запросах и при репликации, база данных <<bench\_replication>>, созданная в разделе
<<\ref{sec:pgpool-II-replica}. Ваша первая репликация>> не может быть повторно использована.
\begin{verbatim}
replication_mode = true
load_balance_mode = false
\end{verbatim}
ИЛИ
\begin{verbatim}
replication_mode = false
load_balance_mode = true
\end{verbatim}

В этом разделе мы установим параметры parallel\_mode и load\_balance\_mode равными true, 
listen\_addresses равным <<*>>, replication\_mode равным false.


