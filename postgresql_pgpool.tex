\chapter{PgPool-II}
\section{Введение}
pgpool-II это прослойка, работающая между серверами PostgreSQL и клиентами СУБД PostgreSQL. 
Она предоставляет следующие функции:
\begin{itemize}
\item \textbf{Объединение соединений} 

pgpool-II сохраняет соединения с серверами PostgreSQL и использует их повторно в случае если новое 
соединение устанавливается с теми же параметрами (т.е. имя пользователя, база данных, версия протокола). 
Это уменьшает накладные расходы на соединения и увеличивает производительность системы вцелом.

\item \textbf{Репликация} 

pgpool-II может управлять множеством серверов PostgreSQL. Использование функции репликации данных позволяет 
создание резервной копии данных в реальном времени на  2 или более физических дисков, так что сервис может 
продолжать работать без остановки серверов в случае выхода из строя диска.

\item \textbf{Балансировка нагрузки}

Если база данных реплицируется, то выполнение запроса SELECT на любом из серверов вернет одинаковый результат. 
pgpool-II использует преимущество функции репликации для уменьшения нагрузки на каждый из серверов PostgreSQL 
распределяя запросы SELECT на несколько серверов, тем самым увеличивая производительность системы вцелом. 
В лучшем случае производительность возрастает пропорционально числу серверов PostgreSQL. Балансировка нагрузки 
лучше всего работает в случае когда много пользователей выполняют много запросов в одно и тоже время.

\item \textbf{Ограничение лишних соединений}

Существует ограничение максимального числа одновременных соединений с PostgreSQL, при превышении которого новые 
соединения отклоняются. Установка максимального числа соединений, в то же время, увеличивает потребление ресурсов и 
снижает производительность системы. pgpool-II также имеет ограничение на максимальное число соединений, но <<лишние>> 
соединения будут поставлены в очередь вместо немедленного возврата ошибки.

\item \textbf{Параллельные запросы}

Используя функцию параллельных запросов можно разнести данные на множество серверов, благодаря чему запрос может 
быть выполнен на всех серверах одновременно для уменьшения общего времени выполнения. Параллельные запросы работают 
лучше всего при поиске в больших объемах данных.
\end{itemize}

pgpool-II общается по протоколу бэкенда и фронтенда PostgreSQL и располагается между ними. 
Таким образом, приложение базы данных (фронтенд) считает что pgpool-II~--- настоящий сервер PostgreSQL, а сервер (бэкенд) 
видит pgpool-II как одного из своих клиентов. Поскольку pgpool-II прозрачен как для сервера, так и для клиента, 
существующие приложения, работающие с базой данных, могут использоваться с pgpool-II практически без изменений в исходном коде.

Оригинал руководства доступен по адресу http://pgpool.projects.postgresql.org/pgpool-II/doc/tutorial-en.html.

\section{Давайте начнем!}
\label{sec:pgpool-II-begin}
Перед тем как использовать репликацию или параллельные запросы мы должны научиться устанавливать и настраивать pgpool-II 
и узлы базы данных.

\subsection{Установка pgpool-II}
Установка pgpool-II очень проста. В каталоге, в который вы распаковали архив 
с исходными текстами, выполните следующие команды.
\begin{verbatim}
$ ./configure
$ make
$ make install
\end{verbatim}

Скрипт configure собирает информацию о вашей системе и использует ее в процедуре компиляции. Вы можете 
указать параметры в командной строке скрипта configure чтобы изменить его поведение по-умолчанию, такие, например, 
как каталог установки. pgpool-II по-умолчанию будет установлен в каталог /usr/local.

Команда make скомпилирует исходный код, а make install установит исполняемые файлы. У вас должно быть право на 
запись в каталог установки.

Обратите внимание: для работы pgpool-II необходима библиотека libpq для PostgreSQL 7.4 или более поздней версии (3 версия протокола).
Если скрипт configure выдает следующее сообщение об ошибке, возможно не установлена библиотека libpq или она не 3 версии.
\begin{verbatim}
configure: error: libpq is not installed or libpq is old
\end{verbatim}

Если библиотека 3 версии, но указанное выше сообщение все-таки выдается, ваша библиотека libpq, вероятно, 
не распознается скриптом configure.

Скрипт configure ищет библиотеку libpq начиная от каталога /usr/local/pgsql. Если вы установили PostgreSQL в каталог 
отличный от /usr/local/pgsql используйте параметры командной строки --with-pgsql или --with-pgsql-includedir вместе с 
параметром --with-pgsql-libdir при запуске скрипта configure.

Во многих Linux системах pgpool-II может находится в репозитории пакетов. 
Для Ubuntu Linux, например, достаточно будет выполнить:
\begin{verbatim}
sudo aptitude install pgpool2
\end{verbatim}

\subsection{Файлы конфигурации}
Параметры конфигурации pgpool-II хранятся в файле pgpool.conf. Формат файла: одна пара <<параметр = значение>> в строке. 
При установке pgpool-II автоматически создается файл pgpool.conf.sample. Мы рекомендуем скопировать его в файл pgpool.conf, 
а затем отредактировать по вашему желанию.
\begin{verbatim}
$ cp /usr/local/etc/pgpool.conf.sample /usr/local/etc/pgpool.conf
\end{verbatim}

pgpool-II принимает соединения только с localhost на порт 9999. Если вы хотите принимать соединения с других хостов, 
установите для параметра listen\_addresses значение <<*>>.
\begin{verbatim}
listen_addresses = 'localhost'
port = 9999
\end{verbatim}

Мы будем использовать параметры по-умолчанию в этом руководстве.

В Ubuntu Linux конфиг находится /etc/pgpool.conf.

\subsection{Настройка команд PCP}
У pgpool-II есть интерфейс для административных целей~--- получить информацию об узлах базы данных, 
остановить pgpool-II и т.д.~--- по сети. Чтобы использовать команды PCP, необходима идентификация пользователя. 
Эта идентификация отличается от идентификации пользователей в PostgreSQL. Имя пользователя и пароль нужно указывать в 
файле pcp.conf. В этом файле имя пользователя и пароль указываются как пара значений, разделенных двоеточием (:). 
Одна пара в строке. Пароли зашифрованы в формате хэша md5.
\begin{verbatim}
postgres:e8a48653851e28c69d0506508fb27fc5
\end{verbatim}

При установке pgpool-II автоматически создается файл pcp.conf.sample. 
Мы рекомендуем скопировать его в файл pcp.conf и отредактировать.
\begin{verbatim}
$ cp /usr/local/etc/pcp.conf.sample /usr/local/etc/pcp.conf
\end{verbatim}

В Ubuntu Linux файл находится /etc/pcp.conf.

Для того чтобы зашифровать ваш пароль в формате хэша md5 используете команду pg\_md5, которая устанавливается как один из 
исполняемых файлов pgpool-II. pg\_md5 принимает текст в параметре командной строки и отображает текст его md5 хэша.

Например, укажите <<postgres>> в качестве параметра командной строки и pg\_md5 выведет текст хэша md5 в стандартный поток вывода.
\begin{verbatim}
$ /usr/bin/pg_md5 postgres
e8a48653851e28c69d0506508fb27fc5
\end{verbatim}

Команды PCP выполняются по сети, так что в файле pgpool.conf должен быть указан номер порта в параметре pcp\_port.

Мы будем использовать значение по-умолчанию для параметра pcp\_port 9898 в этом руководстве.
\begin{verbatim}
pcp_port = 9898
\end{verbatim}


\subsection{Подготовка узлов базы данных}
Теперь нам нужно настроить серверы бэкендов PostgreSQL для pgpool-II. Эти серверы могут быть размещены на одном 
хосте с pgpool-II или на отдельных машинах. Если вы решите разместить серверы на том же хосте, для всех серверов 
должны быть установлены разные номера портов. Если серверы размещены на отдельных машинах, они должны быть настроены 
так чтобы могли принимать сетевые соединения от pgpool-II.

В этом руководстве мы разместили три сервера в рамках одного хоста вместе с pgpool-II и присвоили им номера портов 
5432, 5433, 5434 соответственно. Для настройки pgpool-II отредактируйте файл pgpool.conf как показано ниже.
\begin{verbatim}
backend_hostname0 = 'localhost'
backend_port0 = 5432
backend_weight0 = 1
backend_hostname1 = 'localhost'
backend_port1 = 5433
backend_weight1 = 1
backend_hostname2 = 'localhost'
backend_port2 = 5434
backend_weight2 = 1
\end{verbatim}

В параметрах backend\_hostname, backend\_port, backend\_weight укажите имя хоста узла базы данных, номер порта и 
коэффициент для балансировки нагрузки. В конце имени каждого параметра должен быть указан идентификатор узла путем 
добавления положительного целого числа начиная с 0 (т.е. 0, 1, 2).

Параметры backend\_weight все равны 1, что означает что запросы SELECT равномерно распределены по трем серверам.

\subsection{Запуск/Остановка pgpool-II}
Для старта pgpool-II выполните в терминале следующую команду.
\begin{verbatim}
$ pgpool
\end{verbatim}

Указанная выше команда, однако, не печатает протокол своей работы потому что pgpool отсоединяется от терминала. 
Если вы хотите показать протокол работы pgpool, укажите параметр -n в командной строке при запуске pgpool. 
pgpool-II будет запущен как процесс не-демон и терминал не будет отсоединен.
\begin{verbatim}
$ pgpool -n &
\end{verbatim}

Протокол работы будет печататься на терминал, так что рекомендуемые для использования параметры командной строки, 
например, такие.
\begin{verbatim}
$ pgpool -n -d > /tmp/pgpool.log 2>&1 &
\end{verbatim}

Параметр -d включает генерацию отладочных сообщений.

Указанная выше команда постоянно добавляет выводимый протокол работы в файл /tmp/pgpool.log. Если вам нужно 
ротировать файлы протоколов, передавайте протоколы внешней команде, у которой есть функция ротации протоколов. 
Вам поможет, например, cronolog.
\begin{verbatim}
$ pgpool -n 2>&1 | /usr/sbin/cronolog
  --hardlink=/var/log/pgsql/pgpool.log
  '/var/log/pgsql/%Y-%m-%d-pgpool.log' &
\end{verbatim}

Чтобы остановить процесс pgpool-II, выполните следующую команду.
\begin{verbatim}
$ pgpool stop
\end{verbatim}

Если какие-то из клиентов все еще присоединены, pgpool-II ждет пока они не отсоединятся и потом завершает свою работу. 
Если вы хотите завершить pgpool-II насильно, используйте вместо этой следующую команду.
\begin{verbatim}
$ pgpool -m fast stop
\end{verbatim}

\section{Ваша первая репликация}
\label{sec:pgpool-II-replica}
Репликация включает копирование одних и тех же данных на множество узлов базы данных.

В этом разделе мы будем использовать три узла базы данных, которые мы уже установили в разделе 
<<\ref{sec:pgpool-II-begin}. Давайте начнем!>>, и проведем вас шаг за шагом к созданию системы репликации базы данных. 
Пример данных для репликации будет сгенерирован программой для тестирования pgbench.

\subsection{Настройка репликации}
Чтобы включить функцию репликации базы данных установите значение true для параметра replication\_mode в файле pgpool.conf.
\begin{verbatim}
replication_mode = true
\end{verbatim}

Если параметр replication\_mode равен true, pgpool-II будет отправлять копию принятого запроса на все узлы базы данных.

Если параметр load\_balance\_mode равен true, pgpool-II будет распределять запросы SELECT между узлами базы данных.
\begin{verbatim}
load_balance_mode = true
\end{verbatim}

В этом разделе мы включили оба параметра replication\_mode и load\_balance\_mode.

\subsection{Проверка репликации}
Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. 
Пожалуйста обращайтесь к разделу <<Запуск/Остановка pgpool-II>>.

После настройки pgpool.conf и перезапуска pgpool-II, давайте проверим репликацию в действии 
и посмотрим все ли работает хорошо.

Сначала нам нужно создать базу данных, которую будем реплицировать. Назовем ее <<bench\_replication>>. 
Эту базу данных нужно создать на всех узлах. Используйте команду createdb через pgpool-II и база 
данных будет создана на всех узлах.
\begin{verbatim}
$ createdb -p 9999 bench_replication
\end{verbatim}

Затем мы запустим pgbench с параметром -i. Параметр -i инициализирует базу данных предопределенными 
таблицами и данными в них.
\begin{verbatim}
$ pgbench -i -p 9999 bench_replication
\end{verbatim}

Указанная ниже таблица содержит сводную информацию о таблицах и данных, которые будут созданы при помощи pgbench -i. 
Если на всех узлах базы данных перечисленные таблицы и данные были созданы, репликация работает корректно.

\begin{tabular}{ | c | c | }
  \hline
  Имя таблицы & Число строк \\
  \hline
  branches & 1 \\
  \hline
  tellers & 10 \\
  \hline
  accounts & 100000 \\
  \hline
  history & 0 \\
  \hline
\end{tabular}

Для проверки указанной выше информации на всех узлах используем простой скрипт на shell. 
Приведенный ниже скрипт покажет число строк в таблицах branches, tellers, accounts и history 
на всех узлах базы данных (5432, 5433, 5434).
\begin{verbatim}
$ for port in 5432 5433 5434; do
>     echo $port
>     for table_name in branches tellers accounts history; do
>         echo $table_name
>         psql -c "SELECT count(*) FROM $table_name" -p \
>         $port bench_replication
>     done
> done
\end{verbatim}


\section{Ваш первый параллельный запрос}
Данные из разных диапазонов сохраняются на двух или более узлах базы данных параллельным запросом. 
Это называется распределением (часто используется без перевода термин partitioning прим. переводчика). 
Более того, одни и те же данные на двух и более узлах базы данных могут быть воспроизведены с использованием распределения.

Чтобы включить параллельные запросы в pgpool-II вы должны установить еще одну базу данных, называемую 
<<Системной базой данных>> (<<System Database>>) (далее будем называть ее SystemDB).

SystemDB хранит определяемые пользователем правила, определяющие какие данные будут сохраняться на каких узлах бызы данных. 
Также SystemDB используется чтобы объединить результаты возвращенные узлами базы данных посредством dblink.

В этом разделе мы будем использовать три узла базы данных, которые мы установили в разделе <<\ref{sec:pgpool-II-begin}. 
Давайте начнем!>>, и проведем вас шаг за шагом к созданию системы баз данных с параллельными запросами. 
Для создания примера данных мы снова будем использовать pgbench.

\subsection{Настройка параллельного запроса}
Чтобы включить функцию выполнения параллельных запросов установите для параметра parallel\_mode значение true в файле pgpool.conf.
\begin{verbatim}
parallel_mode = true
\end{verbatim}

Установка параметра parallel\_mode равным true не запустит параллельные запросы автоматически. 
Для этого pgpool-II нужна SystemDB и правила определяющие как распределять данные по узлам базы данных.

Также SystemDB использует dblink для создания соединений с pgpool-II. Таким образом, нужно установить значение 
параметра listen\_addresses таким образом чтобы pgpool-II принимал эти соединения.
\begin{verbatim}
listen_addresses = '*'
\end{verbatim}

Внимание: Репликация не реализована для таблиц, которые распределяются посредством параллельных запросов и, 
в то же время, репликация может быть успешно осуществлена. Вместе с тем, из-за того что набор хранимых данных 
отличается при параллельных запросах и при репликации, база данных <<bench\_replication>>, созданная в разделе
<<\ref{sec:pgpool-II-replica}. Ваша первая репликация>> не может быть повторно использована.
\begin{verbatim}
replication_mode = true
load_balance_mode = false
\end{verbatim}
ИЛИ
\begin{verbatim}
replication_mode = false
load_balance_mode = true
\end{verbatim}

В этом разделе мы установим параметры parallel\_mode и load\_balance\_mode равными true, 
listen\_addresses равным <<*>>, replication\_mode равным false.


\subsection{Настройка SystemDB}
В основном, нет отличий между простой и системной базами данных. Однако, в системной базе данных определяется функция 
dblink и присутствует таблица, в которой хранятся правила распределения данных. Таблицу dist\_def необходимо определять. 
Более того, один из узлов базы данных может хранить системную базу данных, а pgpool-II может использоваться для 
распределения нагрузки каскадным подключеним.

В этом разделе мы создадим SystemDB на узле с портом 5432. Далее приведен список параметров конфигурации для SystemDB
\begin{verbatim}
system_db_hostname = 'localhost'
system_db_port = 5432
system_db_dbname = 'pgpool'
system_db_schema = 'pgpool_catalog'
system_db_user = 'pgpool'
system_db_password = ''
\end{verbatim}

На самом деле, указанные выше параметры являются параметрами по-умолчанию в файле pgpool.conf. Теперь мы должны 
создать пользователя с именем <<pgpool>> и базу данных с именем <<pgpool>> и владельцем <<pgpool>>.
\begin{verbatim}
$ createuser -p 5432 pgpool
$ createdb -p 5432 -O pgpool pgpool
\end{verbatim}

\subsubsection{Установка dblink}
Далее мы должны установить dblink в базу данных <<pgpool>>. dblink~--- один из инструментов включенных в каталог 
contrib исходного кода PostgreSQL.

Для установки dblink на вашей системе выполните следующие команды.
\begin{verbatim}
$ USE_PGXS=1 make -C contrib/dblink
$ USE_PGXS=1 make -C contrib/dblink install
\end{verbatim}

После того как dblink был установлен в вашей системе мы добавим функции dblink в базу данных <<pgpool>>. Если PostgreSQL 
установлен в каталог /usr/local/pgsql, dblink.sql (файл с определениями функций) должен быть установлен в каталог 
/usr/local/pgsql/share/contrib. Теперь выполним следующую команду для добавления функций dblink.
\begin{verbatim}
$ psql -f /usr/local/pgsql/share/contrib/dblink.sql -p 5432 pgpool
\end{verbatim}

\subsubsection{Создание таблицы dist\_def}
Следующим шагом мы создадим таблицу с именем <<dist\_def>>, в которой будут храниться правила распределения данных. 
Поскольку pgpool-II уже был установлен, файл с именем system\_db.sql должен буть установлен в 
/usr/local/share/system\_db.sql (имейте в виду что это учебное руководство и мы использовали для установки каталог 
по-умолчанию – /usr/local). Файл system\_db.sql содержит директивы для создания специальных таблиц, включая и 
таблицу <<dist\_def>>. Выполните следующую команду для создания таблицы <<dist\_def>>.
\begin{verbatim}
$ psql -f /usr/local/share/system_db.sql -p 5432 -U pgpool pgpool
\end{verbatim}

Все таблицы в файле system\_db.sql, включая <<dist\_def>>, создаются в схеме <<pgpool\_catalog>>. Если вы установили 
параметр system\_db\_schema на использование другой схемы вам нужно, соответственно, отредактировать файл system\_db.sql.

Описание таблицы <<dist\_def>> выглядит так как показано ниже. Имя таблицы не должно измениться.
\begin{verbatim}
CREATE TABLE pgpool_catalog.dist_def (
    dbname text, -- имя базы данных
    schema_name text, -- имя схемы
    table_name text, -- имя таблицы
    col_name text NOT NULL CHECK (col_name = ANY (col_list)), 
    -- столбец-ключ для распределения данных
    col_list text[] NOT NULL, -- список имен столбцов
    type_list text[] NOT NULL, -- список типов столбцов
    dist_def_func text NOT NULL, 
    -- имя функции распределения данных
    PRIMARY KEY (dbname, schema_name, table_name)
);
\end{verbatim}

Записи, хранимые в таблице <<dist\_def>>, могут быть двух типов.
\begin{itemize}
\item Правило Распределения Данных (col\_name, dist\_def\_func)
\item Мета-информация о таблицах (dbname, schema\_name, table\_name, col\_list, type\_list)
\end{itemize}

Правило распределения данных определяет как будут распределены данные на конкретный узел базы данных. Данные будут 
распределены в зависимости от значения столбца <<col\_name>>. <<dist\_def\_func>>~--- это функция, которая принимает 
значение <<col\_name>> в качестве агрумента и возвращает целое число, которое соответствует идентификатору узла 
базы данных, на котором должны быть сохранены данные.

Мета-информация используется для того чтобы переписывать запросы. Параллельный запрос должен переписывать исходные запросы 
так чтобы результаты, возвращаемые узлами-бэкендами, могли быть объединены в единый результат.


\subsubsection{Создание таблицы replicate\_def}
В случае если указана таблица, для которой производится репликация в выражение SQL, использующее зарегистрированную в 
dist\_def таблицу путем объединения таблиц, информация о таблице, для которой необходимо производить репликацию, 
предварительно регистрируется в таблице с именем replicate\_def. Таблица replicate\_def уже была создана при обработке
файла system\_db.sql во время создания таблицы dist\_def. Таблица replicate\_def описана так как показано ниже.
\begin{verbatim}
CREATE TABLE pgpool_catalog.replicate_def (
    dbname text, -- имя базы данных
    schema_name text, -- имя схемы
    table_name text, -- имя таблицы
    col_list text[] NOT NULL, -- список имен столбцов
    type_list text[] NOT NULL, -- список типов столбцов
    PRIMARY KEY (dbname, schema_name, table_name)
);
\end{verbatim}


\subsection{Установка правил распределения данных}
В этом учебном руководстве мы определим правила распределения данных, созданных программой pgbench, на три узла 
базы данных. Тестовые данные будут созданы командой <<pgbench -i -s 3>> (т.е. масштабный коэффициент равен 3). 
Для этого раздела мы создадим новую базу данных с именем <<bench\_parallel>>.

В каталоге sample исходного кода pgpool-II вы можете найти файл dist\_def\_pgbench.sql. Мы будем использовать 
этот файл с примером для создания правил распределения для pgbench. Выполните следующую команду в каталоге с распакованным 
исходным кодом pgpool-II.
\begin{verbatim}
$ psql -f sample/dist_def_pgbench.sql -p 5432 pgpool
\end{verbatim}

Ниже представлено описание файла dist\_def\_pgbench.sql.

В файле dist\_def\_pgbench.sql мы добавляем одну строку в таблицу <<dist\_def>>. Это функция распределения данных 
для таблицы accounts. В качестве столбца-ключа указан столбец aid.
\begin{verbatim}
INSERT INTO pgpool_catalog.dist_def VALUES (
    'bench_parallel',
    'public',
    'accounts',
    'aid',
    ARRAY['aid', 'bid', 'abalance', 'filler'],
    ARRAY['integer', 'integer', 'integer', 
    'character(84)'],
    'pgpool_catalog.dist_def_accounts'
);
\end{verbatim}

Теперь мы должны создать функцию распределения данных для таблицы accounts. Заметим, что вы можете использовать 
одну и ту же функцию для разных таблиц. Также вы можете создавать функции с использованием языков отличных от SQL 
(например, PL/pgSQL, PL/Tcl, и т.д.).

Таблица accounts в момент инициализации данных хранит значение масштабного коэффициента равное 3, значения 
столбца aid от 1 до 300000. Функция создана таким образом что данные равномерно распределяются по трем узлам базы данных.

Следующая SQL-функция будет возвращать число узлов базы данных.
\begin{verbatim}
CREATE OR REPLACE FUNCTION 
pgpool_catalog.dist_def_branches(anyelement)
RETURNS integer AS $$
    SELECT CASE WHEN $1 > 0 AND $1 <= 1 THEN 0
        WHEN $1 > 1 AND $1 <= 2 THEN 1
        ELSE 2
    END;
$$ LANGUAGE sql;
\end{verbatim}

\subsection{Установка правил репликации}
Правило репликации~--- это то что определяет какие таблицы должны быть использованы для выполнения репликации.

Здесь это сделано при помощи pgbench с зарегистрированными таблицами branches и tellers.

Как результат, стало возможно создание таблицы accounts и выполнение запросов, использующих таблицы branches и tellers.
\begin{verbatim}
INSERT INTO pgpool_catalog.replicate_def VALUES (
    'bench_parallel',
    'public',
    'branches',
    ARRAY['bid', 'bbalance', 'filler'],
    ARRAY['integer', 'integer', 'character(88)']
);

INSERT INTO pgpool_catalog.replicate_def VALUES (
    'bench_parallel',
    'public',
    'tellers',
    ARRAY['tid', 'bid', 'tbalance', 'filler'],
    ARRAY['integer', 'integer', 'integer', 'character(84)']
);
\end{verbatim}

Подготовленный файл Replicate\_def\_pgbench.sql находится в каталоге sample. Команда psql запускается с указанием пути к 
исходному коду, определяющему правила репликации, например, как показано ниже.
\begin{verbatim}
$ psql -f sample/replicate_def_pgbench.sql -p 5432 pgpool
\end{verbatim}

\subsection{Проверка параллельного запроса}
Для отражения изменений, сделанных в файле pgpool.conf, pgpool-II должен быть перезапущен. 
Пожалуйста обращайтесь к разделу <<Запуск/Остановка pgpool-II>>.

После настройки pgpool.conf и перезапуска pgpool-II, давайте проверим хорошо ли работают параллельные запросы.

Сначала нам нужно создать базу данных, которая будет распределена. Мы назовем ее <<bench\_parallel>>. 
Эту базу данных нужно создать на всех узлах. Используйте команду createdb посредством pgpool-II и база 
данных будет создана на всех узлах.
\begin{verbatim}
$ createdb -p 9999 bench_parallel
\end{verbatim}

Затем запустим pgbench с параметрами -i -s 3. Параметр -i инициализирует базу данных предопределенными 
таблицами и данными. Параметр -s указывает масштабный коэффициент для инициализации.
\begin{verbatim}
$ pgbench -i -s 3 -p 9999 bench_parallel
\end{verbatim}

Созданные таблицы и данные в них показаны в разделе <<Установка правил распределения данных>>.

Один из способов проверить корректно ли были распределены данные~--- выполнить запрос SELECT посредством 
pgpool-II и напрямую на бэкендах и сравнить результаты. Если все настроено правильно база данных 
<<bench\_parallel>> должна быть распределена как показано ниже.

\begin{tabular}{ | c | c | }
  \hline
  Имя таблицы & Число строк \\
  \hline
  branches & 3 \\
  \hline
  tellers & 30 \\
  \hline
  accounts & 300000 \\
  \hline
  history & 0 \\
  \hline
\end{tabular}

Для проверки указанной выше информации на всех узлах и посредством pgpool-II используем простой скрипт на shell. 
Приведенный ниже скрипт покажет минимальное и максимальное значение в таблице accounts используя для соединения 
порты 5432, 5433, 5434 и 9999.
\begin{verbatim}
$ for port in 5432 5433 5434i 9999; do
>     echo $port
>     psql -c "SELECT min(aid), max(aid) FROM accounts" \
>     -p $port bench_parallel
> done
\end{verbatim}


\section{Master-slave режим}
Этот режим предназначен для использования pgpool-II с другой репликацией (например Slony-I, Londiste). 
Информация про БД указывается как для репликации. master\_slave\_mode и load\_balance\_mode устанавливается в true. 
pgpool-II будет посылать запросы INSERT/UPDATE/DELETE на Master DB (1 в списке), а SELECT~--- использовать балансировку 
нагрузки, если это возможно.

При этом, DDL и DML для временной таблицы может быть выполнен только на мастере. Если нужен SELECT только на мастере, то для этого 
нужно использовать комментарий /*NO LOAD BALANCE*/ перед SELECT.

В Master/Slave режиме replication\_mode должен быть установлен false, а master\_slave\_mode~--- true.

\section{Онлайн востановление}
...


