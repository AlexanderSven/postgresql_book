\section{Pg\_repack}
\textbf{Лицензия}: Open Source

\textbf{Ссылка}: \href{http://reorg.github.io/pg\_repack/}{reorg.github.io/pg\_repack/}

Таблицы в PostgreSQL представлены в виде страниц, размером 8Kb, в которых размещены записи. Когда одна страница полностью заполняется записями, к таблице добавляется новая страница. При удалалени записей с помощью DELETE или изменении с помощью UPDATE, место где были старые записи не может быть повторно использовано сразу же. Для этого процесс очистки autovacuum, или команда VACUUM, пробегает по изменённым страницам и помечает такое место как свободное, после чего новые записи могут спокойно записываться в это место. Если autovacuum не справляется, например в результате активного изменения большего количества данных или просто из-за плохих настроек, то к таблице будут излишне добавляться новые страницы по мере поступления новых записей. И даже после того как очистка дойдёт до наших удалённых записей, новые страницы останутся. Получается что таблица становится более разряженной в плане плотности записей. Это и называется эффектом раздувания таблиц, table bloat.

Процедура очистки, autovacuum или VACUUM, может уменьшить размер таблицы убрав полностью пустые страницы, но только при условии что они находятся в самом конце таблицы. Чтобы максимально уменьшить таблицу в PostgreSQL есть VACUUM FULL или CLUSTER, но оба эти способа требуют <<exclusively locks>> на таблицу (то есть в это время с таблицы нельзя ни читать, ни писать), что далеко не всегда является подходящим решением.

Для решение подобных проблем существует расширение pg\_repack. Это расширение позволяет сделать VACUUM FULL или CLUSTER команды без блокировки таблицы. Для чистки таблицы pg\_repack создает точную её копию в <<repack>> схеме базы данных (ваша база по умолчанию работает в <<public>> схеме) и сортирует строки в этой таблице. После переноса данных и чиски мусора, утилита меняет схему у таблиц. Для чистки индексов утилита создает новые индексы с другими именами, а по выполнению работы меняет их на первоначальные. Для выполнения всех этих работ потребуется дополнительное место на диске (например, если у вас 100ГБ данных, и из них 40ГБ - распухание таблиц или индексов, то вам потребуется 100ГБ + (100ГБ - 40ГБ) = 160ГБ на диске минимум). Для проверки <<распухания>> таблиц и индексов в вашей базе можно воспользоватся советом из раздела <<\ref{sec:snippets-bloating}~\nameref{sec:snippets-bloating}>>.

Существует ряд ограничений в работе pg\_repack:

\begin{itemize}
  \item Не может очистить временные таблицы;
  \item Не может очистить таблицы с использованием GIST индексов;
  \item Нельзя выполнять DDL (Data Definition Language) на таблице во время работы.
\end{itemize}

\subsection{Примеры}

Выполнить команду CLUSTER всех кластерных таблиц и VACUUM FULL для всех не кластерных таблиц в test базе данных:

\begin{lstlisting}[language=Bash,label=lst:pgrepack1]
$ pg_repack test
\end{lstlisting}

Выполните команду VACUUM FULL на foo и bar таблицах в test базе данных (кластеризация таблиц игнорируется):

\begin{lstlisting}[language=Bash,label=lst:pgrepack2]
$ pg_repack --no-order --table foo --table bar test
\end{lstlisting}

Переместить все индексы таблицы foo в неймспейс tbs:

\begin{lstlisting}[language=Bash,label=lst:pgrepack3]
$ pg_repack -d test --table foo --only-indexes --tablespace tbs
\end{lstlisting}

\subsection{Заключение}

Pg\_repack~--- расширение, которое может помочь в больбе с <<table bloat>> в PostgreSQL <<на лету>>.