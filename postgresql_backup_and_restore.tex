\chapter{Бэкап и востановление PostgreSQL}
\begin{epigraphs}
\qitem{Есть два типа администраторов~--- те, кто не делает бэкапы, и те, кто уже делает}{Народная мудрость}
\qitem{Если какая-нибудь неприятность может произойти, она случается.}{Закон Мэрфи}
\end{epigraphs}
\section{Введение}
Любой хороший сисадмин знает~--- бэкапы нужны всегда. 
На сколько бы надежна не казалась Ваша система, всегда может произойти случай, который был не учтен, и из-за которого 
могут быть потеряны данные.

Тоже самое касается и PostgreSQL баз данных. Бекапы должны быть! Посыпавшийся винчестер на сервере, ошибка в фаловой системе, 
ошибка в другой программе, которая перетерла весь каталог PostgreSQL и многое другое приведет только к плачевному результату.
И даже если у Вас репликация с множеством слейвов, 
это не означает, что система в безопасности~--- неверный запрос на мастер (DELETE, DROP), и у слейвов такая же порция данных 
(точнее их отсутствие). 

Существуют три принципиально различных подхода к резервному копированию данных PostgreSQL:
\begin{itemize}
\item SQL бэкап;
\item Бекап уровня файловой системы;
\item Непрерывное архивирование;
\end{itemize}
Каждый из этих подходов имеет свои сильные и слабые стороны.


\section{SQL бэкап}
Идея этого подхода в создании текстового файла с командами SQL. Такой файл можно передать обратно на сервер 
и воссоздать базу данных в том же состоянии, в котором она была во время бэкапа. 
У PostgreSQL для этого есть специальная утилита~--- pg\_dump. Пример использования pg\_dump:
\begin{lstlisting}[label=lst:backups1,caption=Создаем бэкап с помощью pg\_dump]
pg_dump dbname > outfile
\end{lstlisting}

Для восстановления такого бэкапа достаточно выполнить:
\begin{lstlisting}[label=lst:backups2,caption=Восстанавливаем бэкап]
psql dbname < infile
\end{lstlisting}

При этом базу данных <<dbname>> потребуется создать перед восстановлением. Также потребуется создать пользователей, 
которые имеют доступ к данным, которые восстанавливаются (это можно и не делать, но тогда просто в выводе востановления будут ошибки).
Если нам требуется, чтобы востановление прекратилось при возникновении ошибки, тогда потребуется восстанавливать бэкап таким способом:
\begin{lstlisting}[label=lst:backups3,caption=Восстанавливаем бэкап]
psql --set ON_ERROR_STOP=on dbname < infile
\end{lstlisting}

Также, можно делать бэкап и сразу восстанавливать его на другую базу:
\begin{lstlisting}[label=lst:backups4,caption=Бекап в другую БД]
pg_dump -h host1 dbname | psql -h host2 dbname
\end{lstlisting}

После восстановления бэкапа желательно запустить <<ANALYZE>>, чтобы оптимизатор запросов обновил статистику.

А что, если нужно сделать бэкап не одной базы данных, а всех, да и еще получить в бэкапе информацию про роли и таблицы? 
В таком случае у PostgreSQL есть утилита pg\_dumpall. pg\_dumpall используется для создания бэкапа данных всего кластера PostgreSQL:
\begin{lstlisting}[label=lst:backups5,caption=Бекап кластера PostgreSQL]
pg_dumpall > outfile
\end{lstlisting}

Для восстановления такого бэкапа достаточно выполнить от суперпользователя:
\begin{lstlisting}[label=lst:backups6,caption=Восстановления бэкапа PostgreSQL]
psql -f infile postgres
\end{lstlisting}

\subsection{SQL бэкап больших баз данных}
Некоторые операционные системы имеют ограничения на максимальный размер файла, что может вызывають проблемы при создании 
больших бэкапов через pg\_dump. К счастью, pg\_dump можете бэкапить в стандартный вывод. Так что можно использовать 
стандартные инструменты Unix, чтобы обойти эту проблему. Есть несколько возможных способов:
\begin{itemize}
\item \textbf{Использовать сжатие для бэкапа.} 

Можно использовать программу сжатия данных, например GZIP:
\begin{lstlisting}[label=lst:backups7,caption=Сжатие бэкапа PostgreSQL]
pg_dump dbname | gzip > filename.gz
\end{lstlisting}

Восстановление:
\begin{lstlisting}[label=lst:backups8,caption=Восстановление бэкапа PostgreSQL]
gunzip -c filename.gz | psql dbname
\end{lstlisting}
или
\begin{lstlisting}[label=lst:backups9,caption=Восстановление бэкапа PostgreSQL]
cat filename.gz | gunzip | psql dbname
\end{lstlisting}

\item \textbf{Использовать команду split.} 

Команда split позволяет разделить вывод в файлы меньшего размера, которые являются подходящими по размеру для файловой системы. 
Например, бэкап делится на куски по 1 мегабайту:
\begin{lstlisting}[label=lst:backups10,caption=Создание бэкапа PostgreSQL]
pg_dump dbname | split -b 1m - filename
\end{lstlisting}
Восстановление:
\begin{lstlisting}[label=lst:backups11,caption=Восстановление бэкапа PostgreSQL]
cat filename* | psql dbname
\end{lstlisting}

\item \textbf{Использовать пользовательский формат дампа pg\_dump}

PostgreSQL построен на системе с библиотекой сжатия Zlib, поэтому пользовательский формат бэкапа будет в сжатом виде. 
Это похоже на метод с импользованием GZIP, но он имеет дополнительное преимущество~--- таблицы могут быть восстановлены выборочно:
\begin{lstlisting}[label=lst:backups12,caption=Создание бэкапа PostgreSQL]
pg_dump -Fc dbname > filename
\end{lstlisting}
Через psql такой бэкап не восстановить, но для этого есть утилита pg\_restore:
\begin{lstlisting}[label=lst:backups13,caption=Восстановление бэкапа PostgreSQL]
pg_restore -d dbname filename
\end{lstlisting}

\end{itemize}

При слишком большой базе данных, вариант с командой split нужно комбинировать с сжатием данных.


\section{Бекап уровня файловой системы}
Альтернативный метод резервного копирования заключается в непосредственном копировании файлов, 
которые PostgreSQL использует для хранения данных в базе данных. Например:
\begin{lstlisting}[label=lst:backups14,caption=Бэкап PostgreSQL файлов]
tar -cf backup.tar /usr/local/pgsql/data
\end{lstlisting}

Но есть два ограничения, которые делает этот метод нецелесообразным, или, по крайней мере, уступающим SQL бэкапу:
\begin{itemize}
\item PostgreSQL база данных должна быть остановленна, для того, чтобы получить актуальный бэкап 
(PostgreSQL держит множество обьектов в памяти, буферизация файловой системы). Излишне говорить, 
что во время востановления такого бэкапа потребуется также остановить PostgreSQL.
\item Не получится востановить только определенные данные с такого бэкапа.
\end{itemize}

Как альтернатива, можно делать снимки (snapshot) файлов системы (папки с файлами PostgreSQL). В таком случае останавливать PostgreSQL 
не требуется. Однако, резервная копия, созданная таким образом, сохраняет файлы базы данных в состоянии, как если бы сервер базы данных 
был неправильно остановлен. Поэтому при запуске PostgreSQL из резервной копии, он будет думать, что предыдущий экземпляр 
сервера вышел из строя и повторит журнала WAL. Это не проблема, просто надо знать про это (и не забыть включить WAL файлы 
в резервную копию). Также, если файловая система PostgreSQL распределена по разным файловым система, то такой метод бэкапа 
будет очень не надежным~--- снимки файлов системы должны быть сделаны одновременно(!!!). Почитайте документацию файловой 
системы очень внимательно, прежде чем доверять снимкам файлов системы в таких ситуациях.

Также возможен вариант с использованием rsync. Первым запуском rsync мы копируем основные файлы с директории PostgreSQL 
(PostgreSQL при этом продолжает работу). После этого 
мы останавливаем PostgreSQL и запускаем повторно rsync. Второй запуск rsync пройдет гораздо быстрее, чем первый, 
потому что будет передавать относительно небольшой размер данных, 
и конечный результат будет соответствовать остановленной СУБД. 
Этот метод позволяет делать бекап уровня файловой системы с минимальным временем простоя.

\section{Непрерывное архивирование}
